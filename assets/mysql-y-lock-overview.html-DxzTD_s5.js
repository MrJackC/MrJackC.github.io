import{_ as l,c as t,a,o as i}from"./app-DQS7qcOs.js";const n={};function p(r,e){return i(),t("div",null,e[0]||(e[0]=[a('<h1 id="锁机制" tabindex="-1"><a class="header-anchor" href="#锁机制"><span>锁机制</span></a></h1><h2 id="_1-锁维度" tabindex="-1"><a class="header-anchor" href="#_1-锁维度"><span>1. 锁维度</span></a></h2><p>锁有好几种维度</p><h3 id="_1-1-类型维度" tabindex="-1"><a class="header-anchor" href="#_1-1-类型维度"><span>1.1 类型维度</span></a></h3><ul><li><p>共享锁（读锁/S锁）</p></li><li><p>排他锁（写锁/X 锁）</p><p>类型细分</p><ul><li>意向共享锁</li><li>意向排他（互斥）锁</li></ul></li><li><p>悲观锁（使用锁，既for update）</p></li><li><p>乐观锁（使用版本号字段，类似 CAS 机制，既用户自己控制。缺点：并发很高的时候，多了很多无用的重试）</p></li></ul><h3 id="_1-2-锁的粒度-粒度维度" tabindex="-1"><a class="header-anchor" href="#_1-2-锁的粒度-粒度维度"><span>1.2 锁的粒度（粒度维度）</span></a></h3><ul><li><p>表锁</p></li><li><p>页锁（Mysql BerkeleyDB 引擎）</p></li><li><p>行锁（InnoDB）</p><p>行锁的实现原理就是锁住聚集索引，如果你查询的时候，没有正确地击中索引，MySql 优化器将会抛弃行锁，使用表锁。</p></li></ul><h3 id="_1-3-锁的算法-算法维度" tabindex="-1"><a class="header-anchor" href="#_1-3-锁的算法-算法维度"><span>1.3 锁的算法（算法维度）</span></a></h3><ul><li>Record Lock（单行记录）</li><li>Gap Lock（间隙锁，锁定一个范围，但不包含锁定记录）</li><li>Next-key Lock（Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身。MySQL 防止幻读，就是使用此锁实现）</li></ul><h2 id="_2-默认的读操作-上锁吗" tabindex="-1"><a class="header-anchor" href="#_2-默认的读操作-上锁吗"><span>2. 默认的读操作，上锁吗？</span></a></h2><p>默认是MVCC机制（“一致性非锁定读”）保证RR 级别的隔离正确性。是不上锁的</p><p>可以选择手动上锁</p><ul><li><p>排他锁：select xxxx for update</p></li><li><p>共享锁：select xxx lock in share mode</p><p>称为一致性锁定读</p></li></ul><p>使用锁之后，就能在RR 级别下，避免幻读。当然默认的MVCC读，也能避免幻读</p><h2 id="_3-mysql-的-serializable-有啥用呢" tabindex="-1"><a class="header-anchor" href="#_3-mysql-的-serializable-有啥用呢"><span>3 MySQL 的 SERIALIZABLE 有啥用呢？</span></a></h2><p>MySQL RR能够防止幻读,那么，SERIALIZABLE 有啥用呢？</p><p>他可以<strong>防止丢失更新</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403130940463.png" alt="image-20190912235538188" tabindex="0" loading="lazy"><figcaption>image-20190912235538188</figcaption></figure><p>这个时候，我们必须使用SERIALIZABLE 级别进行串行读取。</p>',19)]))}const s=l(n,[["render",p],["__file","mysql-y-lock-overview.html.vue"]]),c=JSON.parse('{"path":"/posts/Database/MySQL/mysql-y-lock-overview.html","title":"锁机制","lang":"zh-CN","frontmatter":{"aliases":"锁机制","tags":null,"cssclass":null,"source":null,"created":"2024-02-22 10:49","updated":"2024-03-13 09:40","description":"锁机制 1. 锁维度 锁有好几种维度 1.1 类型维度 共享锁（读锁/S锁） 排他锁（写锁/X 锁） 类型细分 意向共享锁 意向排他（互斥）锁 悲观锁（使用锁，既for update） 乐观锁（使用版本号字段，类似 CAS 机制，既用户自己控制。缺点：并发很高的时候，多了很多无用的重试） 1.2 锁的粒度（粒度维度） 表锁 页锁（Mysql Berke...","head":[["meta",{"property":"og:url","content":"https://mrjackc.github.io/posts/Database/MySQL/mysql-y-lock-overview.html"}],["meta",{"property":"og:site_name","content":"mrjason’s Blog"}],["meta",{"property":"og:title","content":"锁机制"}],["meta",{"property":"og:description","content":"锁机制 1. 锁维度 锁有好几种维度 1.1 类型维度 共享锁（读锁/S锁） 排他锁（写锁/X 锁） 类型细分 意向共享锁 意向排他（互斥）锁 悲观锁（使用锁，既for update） 乐观锁（使用版本号字段，类似 CAS 机制，既用户自己控制。缺点：并发很高的时候，多了很多无用的重试） 1.2 锁的粒度（粒度维度） 表锁 页锁（Mysql Berke..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403130940463.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-21T07:03:09.000Z"}],["meta",{"property":"article:author","content":"MrJason"}],["meta",{"property":"article:modified_time","content":"2024-10-21T07:03:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"锁机制\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403130940463.png\\"],\\"dateModified\\":\\"2024-10-21T07:03:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MrJason\\",\\"url\\":\\"https://mrjackc.github.io\\"}]}"]]},"headers":[{"level":2,"title":"1. 锁维度","slug":"_1-锁维度","link":"#_1-锁维度","children":[{"level":3,"title":"1.1 类型维度","slug":"_1-1-类型维度","link":"#_1-1-类型维度","children":[]},{"level":3,"title":"1.2 锁的粒度（粒度维度）","slug":"_1-2-锁的粒度-粒度维度","link":"#_1-2-锁的粒度-粒度维度","children":[]},{"level":3,"title":"1.3 锁的算法（算法维度）","slug":"_1-3-锁的算法-算法维度","link":"#_1-3-锁的算法-算法维度","children":[]}]},{"level":2,"title":"2. 默认的读操作，上锁吗？","slug":"_2-默认的读操作-上锁吗","link":"#_2-默认的读操作-上锁吗","children":[]},{"level":2,"title":"3 MySQL 的 SERIALIZABLE 有啥用呢？","slug":"_3-mysql-的-serializable-有啥用呢","link":"#_3-mysql-的-serializable-有啥用呢","children":[]}],"git":{"createdTime":1729494189000,"updatedTime":1729494189000,"contributors":[{"name":"MrJason","email":"845886914@qq.com","commits":1}]},"readingTime":{"minutes":1.35,"words":406},"filePathRelative":"posts/Database/MySQL/mysql-y-lock-overview.md","localizedDate":"2024年10月21日","excerpt":"\\n<h2>1. 锁维度</h2>\\n<p>锁有好几种维度</p>\\n<h3>1.1 类型维度</h3>\\n<ul>\\n<li>\\n<p>共享锁（读锁/S锁）</p>\\n</li>\\n<li>\\n<p>排他锁（写锁/X 锁）</p>\\n<p>类型细分</p>\\n<ul>\\n<li>意向共享锁</li>\\n<li>意向排他（互斥）锁</li>\\n</ul>\\n</li>\\n<li>\\n<p>悲观锁（使用锁，既for update）</p>\\n</li>\\n<li>\\n<p>乐观锁（使用版本号字段，类似 CAS 机制，既用户自己控制。缺点：并发很高的时候，多了很多无用的重试）</p>\\n</li>\\n</ul>\\n<h3>1.2 锁的粒度（粒度维度）</h3>","autoDesc":true}');export{s as comp,c as data};
