import{_ as a,c as e,a as i,o as n}from"./app-4x2aIoqi.js";const l={};function r(o,s){return n(),e("div",null,s[0]||(s[0]=[i(`<h1 id="gc日志分析" tabindex="-1"><a class="header-anchor" href="#gc日志分析"><span>gc日志分析</span></a></h1><h2 id="_1-什么时候会发生垃圾收集" tabindex="-1"><a class="header-anchor" href="#_1-什么时候会发生垃圾收集"><span>1. 什么时候会发生垃圾收集</span></a></h2><p>首先我们来看一个问题，那就是什么时候会发生垃圾回收？<br> 在Java中，GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。 当然，我们可以手动进行垃圾回收， 比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说System.gc()只是通知要回收，什么时候回收由JVM决定。<br> 一般以下几种情况会发生垃圾回收：</p><ol><li>当Eden区或者S区不够用时</li><li>老年代空间不够用了时</li><li>方法区空间不够用时</li><li>System.gc() 时</li></ol><blockquote><p>注意：<strong>可能有些人会以为方法区是不会发生垃圾回收的，其实方法区也是会发生垃圾回收的，只不过大部分情况下，方法区发生垃圾回收之后效率不是很高，大部分内存都回收不掉，所以我们一般讨论垃圾回收的时候也只讨论堆内的回收</strong></p></blockquote><h2 id="_2-怎么拿到gc日志" tabindex="-1"><a class="header-anchor" href="#_2-怎么拿到gc日志"><span>2. 怎么拿到GC日志</span></a></h2><p>发生GC之后，我们要分析GC日志，当然就首先要拿到GC日志，JVM参数分类及常用参数分析时有提到，打印GC日志可以通过如下命令：</p><div class="language-bash" data-ext="bash" data-title="bash"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">-XX:+PrintGCDetails</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintGCTimeStamps</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintGCDateStamps</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -Xloggc:./gc.log</span></span></code></pre></div><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958737.png" alt="image-20220429154545836" tabindex="0" loading="lazy"><figcaption>image-20220429154545836</figcaption></figure><p>找到gc.log文件，注意，刚开始如果一次GC都没发生日志是空的，可以等到发生GC之后再打开：</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958785.png" alt="image-20220429154804961" tabindex="0" loading="lazy"><figcaption>image-20220429154804961</figcaption></figure><p>从日志上可以看出来，jdk1.8中默认使用的是Parallel Scavenge+Parallel Old收集器，当然我们也可以通过参数：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>-XX:+PrintCommandLineFlags</span></span></code></pre></div><p>进行打印：</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958813.png" alt="image-20220429154946996" tabindex="0" loading="lazy"><figcaption>image-20220429154946996</figcaption></figure><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>-XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:InitialHeapSize=268435456 -XX:+ManagementServer -XX:MaxHeapSize=4294967296 -XX:+PrintCommandLineFlags -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span></span></code></pre></div><h2 id="_3-gc日志分析" tabindex="-1"><a class="header-anchor" href="#_3-gc日志分析"><span>3. gc日志分析</span></a></h2><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958846.png" alt="image-20220429160003832" tabindex="0" loading="lazy"><figcaption>image-20220429160003832</figcaption></figure><h3 id="_3-1-环境信息" tabindex="-1"><a class="header-anchor" href="#_3-1-环境信息"><span>3.1 环境信息</span></a></h3><div class="language-bash" data-ext="bash" data-title="bash"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 当前所使用的的HotSpot虚拟机及其对应版本号；</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">Java</span><span style="color:#98C379;--shiki-dark:#98C379;"> HotSpot</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">TM</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="color:#98C379;--shiki-dark:#98C379;">64-Bit</span><span style="color:#98C379;--shiki-dark:#98C379;"> Server</span><span style="color:#98C379;--shiki-dark:#98C379;"> VM</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (25.231-b11) </span><span style="color:#C678DD;--shiki-dark:#C678DD;">for</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> bsd-amd64 JRE (</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">1.8.0_231-b11</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">), built on Oct  </span><span style="color:#D19A66;--shiki-dark:#D19A66;">5</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 2019</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> 03:15:25 by </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;java_re&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> with gcc </span><span style="color:#D19A66;--shiki-dark:#D19A66;">4.2.1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">Based</span><span style="color:#98C379;--shiki-dark:#98C379;"> on</span><span style="color:#98C379;--shiki-dark:#98C379;"> Apple</span><span style="color:#98C379;--shiki-dark:#98C379;"> Inc.</span><span style="color:#98C379;--shiki-dark:#98C379;"> build</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 5658</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) (</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">LLVM</span><span style="color:#98C379;--shiki-dark:#98C379;"> build</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 2336.11.00</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 操作系统相关的内存信息；</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">Memory:</span><span style="color:#98C379;--shiki-dark:#98C379;"> 4k</span><span style="color:#98C379;--shiki-dark:#98C379;"> page,</span><span style="color:#98C379;--shiki-dark:#98C379;"> physical</span><span style="color:#98C379;--shiki-dark:#98C379;"> 16777216k</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">2322260k</span><span style="color:#98C379;--shiki-dark:#98C379;"> free</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span></code></pre></div><h3 id="_3-2-配置的参数信息" tabindex="-1"><a class="header-anchor" href="#_3-2-配置的参数信息"><span>3.2 配置的参数信息</span></a></h3><ul><li>初始堆大小：268435456B=&gt;256M</li><li>最大堆大小：4294967296B=&gt;4096M=&gt;4G</li></ul><div class="language-bash" data-ext="bash" data-title="bash"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 当前Java服务启动后配置的参数信息：</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">CommandLine</span><span style="color:#98C379;--shiki-dark:#98C379;"> flags:</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:-BytecodeVerificationLocal</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:-BytecodeVerificationRemote</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:InitialHeapSize=268435456</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+ManagementServer</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:MaxHeapSize=4294967296</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintCommandLineFlags</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintGC</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintGCDateStamps</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintGCDetails</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintGCTimeStamps</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:TieredStopAtLevel=1</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+UseCompressedClassPointers</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+UseCompressedOops</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+UseParallelGC</span></span></code></pre></div><p>包括了堆空间打印，以及使用的垃圾收集器及我们自己配置的打印GC日志相关参数等一些信息。</p><h3 id="_3-3-真正的gc日志" tabindex="-1"><a class="header-anchor" href="#_3-3-真正的gc日志"><span>3.3 真正的GC日志</span></a></h3><p>我们把第7行还有第11行复制出来分析一下：</p><div class="language-bash" data-ext="bash" data-title="bash"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 第7行</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">2022-04-29T15:49:04.317-0800:</span><span style="color:#98C379;--shiki-dark:#98C379;"> 6.159:</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> [GC (Allocation </span><span style="color:#98C379;--shiki-dark:#98C379;">Failure</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) [PSYoungGen: 65536K-</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">4671K(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">76288</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">K)] 65536K-&gt;4743K(</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">251392K</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">), 0.0045293 secs] [Times: user</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.01</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> sys</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">0.00, real</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.01</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> secs] </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 第11行</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">2022-04-29T15:49:15.162-0800:</span><span style="color:#98C379;--shiki-dark:#98C379;"> 17.005:</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> [Full </span><span style="color:#98C379;--shiki-dark:#98C379;">GC</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (Metadata </span><span style="color:#98C379;--shiki-dark:#98C379;">GC</span><span style="color:#98C379;--shiki-dark:#98C379;"> Threshold</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) [PSYoungGen: 8154K-</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">0K(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">141824</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">K)] [ParOldGen: 541K-</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">7884K(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">79360</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">K)] 8696K-&gt;7884K(</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">221184K</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">), [Metaspace: 20482K-</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">20482K(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">1067008</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">K)], 0.0263932 secs] [Times: user</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.09</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> sys</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">0.01, real</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.02</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> secs]</span></span></code></pre></div><ol><li><p>最前面一个时间2022-04-29T15:49:04.317-0800 代表的是垃圾回收发生的时间。</p></li><li><p>紧接着下面的一个数字：6.159 表示的是从Java虚拟机启动以来经过的秒数。</p></li><li><p>再往下一个GC (Allocation Failure)表示发生GC的原因，这里是表示分配空间失败而发生了GC。</p></li><li><p>PSYoungGen，PS表示的是Parallel Scavenge收集器，YoungGen表示的是当前发生GC的地方是年轻代，注意，这里不同收集器会有不同的名字，如ParNew收集器就会显示为ParNew等。</p></li><li><p>中括号之内的一个数字65536K-&gt;4671K(76288K)这个表示的是：GC前当前内存区域使用空间64MB-&gt;GC后当前内存区域使用的内存空间4.56M(当前区域的总内存空间74.5M)。从这里可以看到，一次GC之后，大部分空间都被回收掉了。</p></li><li><p>中括号之外的数字65536K-&gt;4743K(251392K)这个表示的是：GC前Java堆已使用容量64MB-&gt;GC后Java堆已使用容量4.6MB(Java堆使用的总容量245M)<br> 这里需要注意的是5和6中的这两组数字相减得到的值一般是不相等的，这是因为总空间下面还包括了老年代发生回收后释放的空间大小，可能有人会觉得奇怪，这里明明只有新生代发生了GC，为什么老年代会有空间释放？<br> 不知道大家还记不记得我在前两篇文章中提到了，<strong>S区如果空间不够的话会利用担保机制向老年代借用空间，所以借来的空间时可能被释放的</strong>，如果想详细了解的S区的担保机制的话可以<a href="https://blog.csdn.net/zwx900102/article/details/108108555" target="_blank" rel="noopener noreferrer">点击这里</a>。</p><blockquote><p>简单点说就是：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）；</p><p><strong>注意：Minor GC堆内存总容量 = 9/10年轻代 + 老年代。原因是Survivor区只计算from部分，而JVM默认年轻代中Eden区和Survivor区的比例关系，Eden:S0:S1=8:1:1。</strong></p></blockquote></li><li><p>0.0045293 secs这个表示的是GC所花费时间，secs表示单位是秒。</p></li><li><p>[Times: user=0.01 sys=0.00, real=0.01 secs] 这一部分并不是所有的垃圾收集器都会打印，user=0.01表示用户态消耗的CPU时间，sys=0.00表示内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间。</p></li><li><p>最后再看看其他行ParOldGen表示Parallel Old收集器在回收老年代，Metaspace表示的是方法区(jdk1.7是永久代)</p></li><li><p>我们看到第11行Full GC表示发生了Full GC，FullGC=Minor GC+Major GC+Metaspace GC，所以后面可以看到PSYoungGen，ParOldGen，Metaspace三个区域的回收信息，而且第11行对比非常明显，新生代全部回收掉了，老年代回收了一小部分，而方法区一点都没有回收掉，这也体现了三个区域内所存对象的区别。</p></li></ol><h4 id="_3-3-1-gc日志情况" tabindex="-1"><a class="header-anchor" href="#_3-3-1-gc日志情况"><span>3.3.1 gc日志情况</span></a></h4><h5 id="_3-2-1-1-默认情况" tabindex="-1"><a class="header-anchor" href="#_3-2-1-1-默认情况"><span>3.2.1.1 默认情况</span></a></h5><p>由该gc日志可知：初始堆256M，最大堆4G 的情况下</p><blockquote><p>以下值并不是固定的，在初始值不够时还会向jvm申请</p></blockquote><ul><li>年轻代：76288K=74.5M</li><li>老年代：221184K = 216M</li><li>元空间：1067008K=1042M</li></ul><h5 id="_3-2-1-2-堆设置为512-新生代与老年代比值设为1" tabindex="-1"><a class="header-anchor" href="#_3-2-1-2-堆设置为512-新生代与老年代比值设为1"><span>3.2.1.2 堆设置为512,新生代与老年代比值设为1</span></a></h5><div class="language-bash" data-ext="bash" data-title="bash"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">2022-05-05T15:45:14.545-0800:</span><span style="color:#98C379;--shiki-dark:#98C379;"> 52.326:</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> [Full </span><span style="color:#98C379;--shiki-dark:#98C379;">GC</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (Metadata </span><span style="color:#98C379;--shiki-dark:#98C379;">GC</span><span style="color:#98C379;--shiki-dark:#98C379;"> Threshold</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) [PSYoungGen: 25963K-</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">0K(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">207872</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">K)] [ParOldGen: 83587K-</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">105673K(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">262144</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">K)] 109551K-&gt;105673K(</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">470016K</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">), [Metaspace: 94852K-</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">94852K(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">1136640</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">K)], 0.4118760 secs] [Times: user</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;">2.08</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> sys</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">0.03, real</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.41</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> secs]</span></span></code></pre></div><ul><li>新生代：207872K=203M</li><li>老年代：262144K= 256M= 正好是总堆的一半</li><li>元空间：1136640K=1110M</li></ul><blockquote><p><strong>注意：Minor GC堆内存总容量 = 9/10年轻代 + 老年代。原因是Survivor区只计算from部分，而JVM默认年轻代中Eden区和Survivor区的比例关系，Eden:S0:S1=8:1:1。</strong></p></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958873.png" alt="image-20220505155043126" tabindex="0" loading="lazy"><figcaption>image-20220505155043126</figcaption></figure><h2 id="_4-墙钟时间和cpu时间" tabindex="-1"><a class="header-anchor" href="#_4-墙钟时间和cpu时间"><span>4. 墙钟时间和cpu时间</span></a></h2><p>墙钟时间(Wall Clock Time)包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些不需要消耗CPU的时间。</p><h2 id="_5-cms日志分析" tabindex="-1"><a class="header-anchor" href="#_5-cms日志分析"><span>5. CMS日志分析</span></a></h2><p>我们垃圾收集器切换为CMS</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#56B6C2;--shiki-dark:#56B6C2;">-</span><span style="color:#E06C75;--shiki-dark:#E06C75;">XX</span><span style="color:#C678DD;--shiki-dark:#C678DD;">:</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">+</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">UseConcMarkSweepGC</span></span></code></pre></div><p>注意，CMS也是一款老年代收集器，使用这个参数后新生代默认会使用ParNew收集器<br> 然后重启服务，等候垃圾回收之后，打开gc.log文件。</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958904.png" alt="image-20220429161025196" tabindex="0" loading="lazy"><figcaption>image-20220429161025196</figcaption></figure><p>前面两行和上面一样，我们把第6行复制出来看看垃圾收集器是否切换成功：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>CommandLine flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:InitialHeapSize=268435456 -XX:+ManagementServer -XX:MaxHeapSize=4294967296 -XX:MaxNewSize=697933824 -XX:MaxTenuringThreshold=6 -XX:OldPLABSize=16 -XX:+PrintCommandLineFlags -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span></span></code></pre></div><p>可以看到，CMS和ParNew两个收集器都启用了。打开第7行日志：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>2022-04-29T16:09:11.428-0800: 5.777: [GC (Allocation Failure) 2022-04-29T16:09:11.433-0800: 5.782: [ParNew: 69952K-&gt;4668K(78656K), 0.0045270 secs] 69952K-&gt;4668K(253440K), 0.0093551 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</span></span></code></pre></div><p>这里的回收信息和上面一样，也就是新生代名字不一样，这里叫ParNew。我们主要看看老年代CMS的GC日志，我们把一个完成的老年代回收日志复制出来：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>2020-08-23T17:00:47.650+0800: 18.182: [GC (CMS Initial Mark) [1 CMS-initial-mark: 30298K(86016K)] 34587K(124736K), 0.0014342 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span>
<span class="line"><span>2020-08-23T17:00:47.651+0800: 18.183: [CMS-concurrent-mark-start]</span></span>
<span class="line"><span>2020-08-23T17:00:47.712+0800: 18.244: [CMS-concurrent-mark: 0.061/0.061 secs] [Times: user=0.13 sys=0.00, real=0.06 secs] </span></span>
<span class="line"><span>2020-08-23T17:00:47.712+0800: 18.244: [CMS-concurrent-preclean-start]</span></span>
<span class="line"><span>2020-08-23T17:00:47.714+0800: 18.245: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span>
<span class="line"><span>2020-08-23T17:00:47.714+0800: 18.246: [CMS-concurrent-abortable-preclean-start]</span></span>
<span class="line"><span>2020-08-23T17:00:48.143+0800: 18.674: [GC (Allocation Failure) 2020-08-23T17:00:48.143+0800: 18.674: [ParNew: 38720K-&gt;4111K(38720K), 0.0101415 secs] 69018K-&gt;38573K(124736K), 0.0102502 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] </span></span>
<span class="line"><span>2020-08-23T17:00:48.451+0800: 18.983: [CMS-concurrent-abortable-preclean: 0.274/0.737 secs] [Times: user=0.94 sys=0.13, real=0.74 secs] </span></span>
<span class="line"><span>2020-08-23T17:00:48.451+0800: 18.983: [GC (CMS Final Remark) [YG occupancy: 23345 K (38720 K)]2020-08-23T17:00:48.451+0800: 18.983: [Rescan (parallel) , 0.0046112 secs]2020-08-23T17:00:48.456+0800: 18.987: [weak refs processing, 0.0006259 secs]2020-08-23T17:00:48.457+0800: 18.988: [class unloading, 0.0062187 secs]2020-08-23T17:00:48.463+0800: 18.994: [scrub symbol table, 0.0092387 secs]2020-08-23T17:00:48.472+0800: 19.004: [scrub string table, 0.0006408 secs][1 CMS-remark: 34461K(86016K)] 57806K(124736K), 0.0219024 secs] [Times: user=0.05 sys=0.01, real=0.02 secs] </span></span>
<span class="line"><span>2020-08-23T17:00:48.473+0800: 19.005: [CMS-concurrent-sweep-start]</span></span>
<span class="line"><span>2020-08-23T17:00:48.489+0800: 19.020: [CMS-concurrent-sweep: 0.015/0.015 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] </span></span>
<span class="line"><span>2020-08-23T17:00:48.489+0800: 19.020: [CMS-concurrent-reset-start]</span></span>
<span class="line"><span>2020-08-23T17:00:48.492+0800: 19.023: [CMS-concurrent-reset: 0.003/0.003 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span></span></code></pre></div><ol><li>CMS Initial Mark对应的是CMS工作机制的第一步<strong>初始标记</strong>，主要是寻找GCRoot对象</li><li>中括号内10443K(86016K)表示的是当前区域已经使用大小和总空间大小</li><li>中括号外13477K(124736K)表示的是堆内已使用空间大小和堆内总空间大小</li><li>CMS-concurrent-mark-start这里对应了CMS工作机制中的第二步<strong>并发标记</strong>。这个阶段主要是根据GCRoot对象遍历整个引用链</li><li>再往后面一行CMS-concurrent-mark: 0.052/0.052 secs，这里的两个时间，第一个表示该阶段持续的cpu时间和墙钟时间</li><li>后面的CMS-concurrent-preclean和CMS-concurrent-abortable-preclean对应了预清理和可中断预清理阶段</li><li>CMS-concurrent-sweep-start对应最终标记，此阶段需要STW，可以看到，在此阶段前发生了一次Young GC,这是为了减少STW时间。</li><li>CMS-concurrent-sweep并发清除垃圾，CMS-concurrent-reset重置线程</li></ol><h2 id="_6-g1日志分析" tabindex="-1"><a class="header-anchor" href="#_6-g1日志分析"><span>6. G1日志分析</span></a></h2><p>切换到G1垃圾收集器：</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#56B6C2;--shiki-dark:#56B6C2;">-</span><span style="color:#E06C75;--shiki-dark:#E06C75;">XX</span><span style="color:#C678DD;--shiki-dark:#C678DD;">:</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">+</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">UseG1GC</span></span></code></pre></div><p>然后重启服务，等待发生垃圾回收之后打开gc.log文件：</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958934.png" alt="image-20220429161709649" tabindex="0" loading="lazy"><figcaption>image-20220429161709649</figcaption></figure><p>可以看到，这个文件相比较于其他垃圾收集器要复杂的多。我们还是先看下第6行，确认是否使用了G1收集器：</p><div class="language-bash" data-ext="bash" data-title="bash"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">CommandLine</span><span style="color:#98C379;--shiki-dark:#98C379;"> flags:</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:-BytecodeVerificationLocal</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:-BytecodeVerificationRemote</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:InitialHeapSize=268435456</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+ManagementServer</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:MaxHeapSize=4294967296</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintCommandLineFlags</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintGC</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintGCDateStamps</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintGCDetails</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+PrintGCTimeStamps</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:TieredStopAtLevel=1</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+UseCompressedClassPointers</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+UseCompressedOops</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> -XX:+UseG1GC</span></span></code></pre></div><p>可以看到确实使用了G1收集器。我们找到一次完整的G1日志，复制出来：</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">2020-08-23T18:44:39.787+0800:</span><span style="color:#98C379;--shiki-dark:#98C379;"> 2.808:</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> [GC </span><span style="color:#98C379;--shiki-dark:#98C379;">pause</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (G1 </span><span style="color:#98C379;--shiki-dark:#98C379;">Evacuation</span><span style="color:#98C379;--shiki-dark:#98C379;"> Pause</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) (</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">young</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">), 0.0029103 secs]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   [Parallel Time: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1.9</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms, GC Workers: 4]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [GC Worker Start (</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ms</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): Min: 2807.7, Avg: 2807.8, Max: 2807.8, Diff: 0.1]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Ext Root Scanning (</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ms</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): Min: 0.3, Avg: 0.6, Max: 0.8, Diff: 0.5, Sum: 2.2]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Update RS (</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ms</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Scan RS (</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ms</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Code Root Scanning (</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ms</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Object Copy (</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ms</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): Min: 0.9, Avg: 1.2, Max: 1.4, Diff: 0.5, Sum: 4.6]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Termination (</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ms</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">         [Termination Attempts: Min: 1, Avg: 2.5, Max: 4, Diff: 3, Sum: 10]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [GC Worker Other (</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ms</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.2]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [GC Worker Total (</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ms</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): Min: 1.7, Avg: 1.8, Max: 1.8, Diff: 0.1, Sum: 7.1]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [GC Worker End (</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ms</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): Min: 2809.5, Avg: 2809.5, Max: 2809.5, Diff: 0.0]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   [Code Root Fixup: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   [Code Root Purge: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   [Clear CT: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   [Other: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1.0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Choose CSet: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Ref Proc: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.8</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Ref Enq: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Redirty Cards: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Humongous Register: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Humongous Reclaim: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      [Free CSet: </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ms]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   [Eden: 6144.0K(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">6144</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">K)-</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">0.0B(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">12</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">M) Survivors: 0.0B-</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">1024.0K Heap: 6144.0K(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">126</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">M)-</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">1520.0K(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">126</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">M)]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> [Times: user</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.00</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> sys</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">0.00, real</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0.00</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> secs]</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>[GC pause (G1 Evacuation Pause) (young), 0.0029103 secs]这里表示发生GC的区域是Young区，后面就是总共耗费的时间。<br> 注意：<strong>G1虽然在物理上取消了区域的划分，但是逻辑上依然保留了，所以日志中还是会显示young，Full GC会用mixed来表示。</strong></li><li>[Parallel Time: 1.9 ms, GC Workers: 4] 这句表示线程的并行时间和并行的线程数</li><li>[GC Worker Start (ms): Min: 2807.7, Avg: 2807.8, Max: 2807.8, Diff: 0.1]这个表示并行的每个线程的开始时间最小值，平均值和最大值以及时间差(Max-Min)。</li></ul><p><a href="https://dzone.com/articles/understanding-g1-gc-log-format" target="_blank" rel="noopener noreferrer">详细日志介绍</a></p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958954.png" alt="image-20220429170801285" tabindex="0" loading="lazy"><figcaption>image-20220429170801285</figcaption></figure><h2 id="_7-利用工具分析gc日志" tabindex="-1"><a class="header-anchor" href="#_7-利用工具分析gc日志"><span>7. 利用工具分析GC日志</span></a></h2><p>虽然说我们从日志上能看懂GC日志，但是如果需要进行调优，我们最关注的是2个点：</p><ul><li>1、吞吐量(Throughput)<br> 吞吐量=运行用户代码时间/(运行用户代码时间+GC时间)</li><li>2、GC暂停时间(Pause Time)<br> Stop The World时间</li></ul><p>那么我们直接从GC日志上很难看出来这两个指标，如果要靠自己计算去确认问题，我觉得这会是一个噩梦。所以同样的，我们需要有工具来帮助我们分析，下面就介绍2款常用的工具。</p><h3 id="_7-1-gceasy" tabindex="-1"><a class="header-anchor" href="#_7-1-gceasy"><span>7.1 gceasy</span></a></h3><ul><li>1、打开官网地址：<a href="https://gceasy.io/" target="_blank" rel="noopener noreferrer">https://gceasy.io/</a></li><li>2、上传gc日志</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958981.png" alt="image-20220429162028875" tabindex="0" loading="lazy"><figcaption>image-20220429162028875</figcaption></figure><p>然后可以进入主页面：</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958009.png" alt="image-20220429162344093" tabindex="0" loading="lazy"><figcaption>image-20220429162344093</figcaption></figure><p>这里已经帮我们把吞吐量和GC暂停时间统计出来了，当然还有其他指标也有统计，有了工具我们就可以对比指标来确认哪种收集器适合自己的系统了。</p><h3 id="_7-2-gcviewer" tabindex="-1"><a class="header-anchor" href="#_7-2-gcviewer"><span>7.2 GCViewer</span></a></h3><ul><li>1、下载gcviewer的jar包</li><li>2、执行命令java -jar gcviewer-1.36-SNAPSHOT.jar</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958039.png" alt="image-20220429162437651" tabindex="0" loading="lazy"><figcaption>image-20220429162437651</figcaption></figure><p>打开主界面：</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958068.png" alt="image-20220429162453125" tabindex="0" loading="lazy"><figcaption>image-20220429162453125</figcaption></figure><p>点击File–&gt;Open File</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958096.png" alt="image-20220429162516855" tabindex="0" loading="lazy"><figcaption>image-20220429162516855</figcaption></figure><p>在右边的第一个Summary概要里面可以看到吞吐量的统计。<br> 切换到第三个标签Pause：</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958125.png" alt="image-20220429162529885" tabindex="0" loading="lazy"><figcaption>image-20220429162529885</figcaption></figure><p>可以查看到各种停顿时间的统计。</p><h2 id="_8-各gc收集器对比报告" tabindex="-1"><a class="header-anchor" href="#_8-各gc收集器对比报告"><span>8. 各GC收集器对比报告</span></a></h2><p>该对比是我比较复杂的一个项目，启动初始化环节的简单对比</p><table><thead><tr><th>对比项目</th><th>新生代Parallel Scavenge+老年代Parallel Old</th><th>新生代ParNew 老年代 CMS</th><th>G1收集器</th><th>总结</th></tr></thead><tbody><tr><td>吞吐量</td><td>98.444%</td><td>98.758%</td><td>98.713%</td><td>吞吐量都为98%，差别不大</td></tr><tr><td>平均GC时间</td><td>51.1ms</td><td>10.1ms</td><td>12.4ms</td><td>Parallel 平均时间慢不少</td></tr><tr><td>最长gc时间</td><td>360ms</td><td>110ms</td><td>30ms</td><td>G1 还是挺强的</td></tr></tbody></table><h3 id="_8-1-新生代parallel-scavenge-老年代parallel-old" tabindex="-1"><a class="header-anchor" href="#_8-1-新生代parallel-scavenge-老年代parallel-old"><span>8.1 新生代Parallel Scavenge+老年代Parallel Old</span></a></h3><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958154.png" alt="image-20220429163708425" tabindex="0" loading="lazy"><figcaption>image-20220429163708425</figcaption></figure><h3 id="_8-2-新生代parnew-老年代-cms" tabindex="-1"><a class="header-anchor" href="#_8-2-新生代parnew-老年代-cms"><span>8.2 新生代ParNew 老年代 CMS</span></a></h3><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958184.png" alt="image-20220429164043614" tabindex="0" loading="lazy"><figcaption>image-20220429164043614</figcaption></figure><h3 id="_8-3-g1收集器-独立完成" tabindex="-1"><a class="header-anchor" href="#_8-3-g1收集器-独立完成"><span>8.3 G1收集器（独立完成）</span></a></h3><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958211.png" alt="image-20220429164317116" tabindex="0" loading="lazy"><figcaption>image-20220429164317116</figcaption></figure><h2 id="_9-gc原因" tabindex="-1"><a class="header-anchor" href="#_9-gc原因"><span>9. GC原因</span></a></h2><ul><li>Allocation Failure：表明本次引起GC的原因是因为新生代中没有足够的区域存放需要分配的数据；</li><li>Metadata GC Threshold：Metaspace区不够用了；</li><li>FErgonomics：JVM自适应调整导致的GC；</li><li>System：调用了System.gc()方法；</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>本文主要介绍了常用的垃圾收集器的GC日志应该如何进行分析，并且介绍了两款常用的工具来帮助我们更好更直观的分析GC日志。</p><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章"><span>参考文章</span></a></h2><p><a href="http://blog.sikacode.com/article/32" target="_blank" rel="noopener noreferrer">【JVM系列7】GC日志都不会看，还怎么进行JVM调优?</a></p>`,99)]))}const t=a(l,[["render",r],["__file","java-jvm-gc-log.html.vue"]]),c=JSON.parse('{"path":"/posts/Java/JavaJVM/java-jvm-gc-log.html","title":"gc日志分析","lang":"zh-CN","frontmatter":{"aliases":"gc日志分析","tags":null,"cssclass":null,"source":null,"category":["Java","JVM"],"created":"2024-02-22 10:47","updated":"2024-03-12 09:59","description":"gc日志分析 1. 什么时候会发生垃圾收集 首先我们来看一个问题，那就是什么时候会发生垃圾回收？ 在Java中，GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。 当然，我们可以手动进行垃圾回收， 比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说System.gc()只是通知要回...","watermark":true,"head":[["meta",{"property":"og:url","content":"https://springg.us.kg/posts/Java/JavaJVM/java-jvm-gc-log.html"}],["meta",{"property":"og:site_name","content":"mrjason’s Blog"}],["meta",{"property":"og:title","content":"gc日志分析"}],["meta",{"property":"og:description","content":"gc日志分析 1. 什么时候会发生垃圾收集 首先我们来看一个问题，那就是什么时候会发生垃圾回收？ 在Java中，GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。 当然，我们可以手动进行垃圾回收， 比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说System.gc()只是通知要回..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958737.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-21T07:03:09.000Z"}],["meta",{"property":"article:author","content":"MrJason"}],["meta",{"property":"article:modified_time","content":"2024-10-21T07:03:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"gc日志分析\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958737.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958785.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958813.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958846.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958873.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958904.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958934.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958954.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958981.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958009.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958039.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958068.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958096.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958125.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958154.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958184.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120958211.png\\"],\\"dateModified\\":\\"2024-10-21T07:03:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MrJason\\",\\"url\\":\\"https://springg.us.kg\\"}]}"]]},"headers":[{"level":2,"title":"1. 什么时候会发生垃圾收集","slug":"_1-什么时候会发生垃圾收集","link":"#_1-什么时候会发生垃圾收集","children":[]},{"level":2,"title":"2. 怎么拿到GC日志","slug":"_2-怎么拿到gc日志","link":"#_2-怎么拿到gc日志","children":[]},{"level":2,"title":"3. gc日志分析","slug":"_3-gc日志分析","link":"#_3-gc日志分析","children":[{"level":3,"title":"3.1 环境信息","slug":"_3-1-环境信息","link":"#_3-1-环境信息","children":[]},{"level":3,"title":"3.2 配置的参数信息","slug":"_3-2-配置的参数信息","link":"#_3-2-配置的参数信息","children":[]},{"level":3,"title":"3.3 真正的GC日志","slug":"_3-3-真正的gc日志","link":"#_3-3-真正的gc日志","children":[]}]},{"level":2,"title":"4. 墙钟时间和cpu时间","slug":"_4-墙钟时间和cpu时间","link":"#_4-墙钟时间和cpu时间","children":[]},{"level":2,"title":"5. CMS日志分析","slug":"_5-cms日志分析","link":"#_5-cms日志分析","children":[]},{"level":2,"title":"6. G1日志分析","slug":"_6-g1日志分析","link":"#_6-g1日志分析","children":[]},{"level":2,"title":"7. 利用工具分析GC日志","slug":"_7-利用工具分析gc日志","link":"#_7-利用工具分析gc日志","children":[{"level":3,"title":"7.1 gceasy","slug":"_7-1-gceasy","link":"#_7-1-gceasy","children":[]},{"level":3,"title":"7.2 GCViewer","slug":"_7-2-gcviewer","link":"#_7-2-gcviewer","children":[]}]},{"level":2,"title":"8. 各GC收集器对比报告","slug":"_8-各gc收集器对比报告","link":"#_8-各gc收集器对比报告","children":[{"level":3,"title":"8.1 新生代Parallel Scavenge+老年代Parallel Old","slug":"_8-1-新生代parallel-scavenge-老年代parallel-old","link":"#_8-1-新生代parallel-scavenge-老年代parallel-old","children":[]},{"level":3,"title":"8.2 新生代ParNew 老年代 CMS","slug":"_8-2-新生代parnew-老年代-cms","link":"#_8-2-新生代parnew-老年代-cms","children":[]},{"level":3,"title":"8.3 G1收集器（独立完成）","slug":"_8-3-g1收集器-独立完成","link":"#_8-3-g1收集器-独立完成","children":[]}]},{"level":2,"title":"9. GC原因","slug":"_9-gc原因","link":"#_9-gc原因","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1729494189000,"updatedTime":1729494189000,"contributors":[{"name":"MrJason","email":"845886914@qq.com","commits":1}]},"readingTime":{"minutes":12.93,"words":3878},"filePathRelative":"posts/Java/JavaJVM/java-jvm-gc-log.md","localizedDate":"2024年10月21日","excerpt":"\\n<h2>1. 什么时候会发生垃圾收集</h2>\\n<p>首先我们来看一个问题，那就是什么时候会发生垃圾回收？<br>\\n在Java中，GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。 当然，我们可以手动进行垃圾回收， 比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说System.gc()只是通知要回收，什么时候回收由JVM决定。<br>\\n一般以下几种情况会发生垃圾回收：</p>\\n<ol>\\n<li>当Eden区或者S区不够用时</li>\\n<li>老年代空间不够用了时</li>\\n<li>方法区空间不够用时</li>\\n<li>System.gc() 时</li>\\n</ol>","autoDesc":true}');export{t as comp,c as data};
