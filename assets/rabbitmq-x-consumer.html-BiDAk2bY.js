import{_ as a,c as n,a as i,o as e}from"./app-W9QyTiMU.js";const l={};function r(o,s){return e(),n("div",null,s[0]||(s[0]=[i(`<h1 id="rabbitmq进阶-消费端要点介绍" tabindex="-1"><a class="header-anchor" href="#rabbitmq进阶-消费端要点介绍"><span>RabbitMQ进阶 - 消费端要点介绍</span></a></h1><h2 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介"><span>1. 简介</span></a></h2><p>消费者客户端可以通过 <strong>推模式</strong> 和 <strong>拉模式</strong> 来获取并消费消息，RabbitMQ 把消息推送后（或客户端主动 ACK）后，RabbitMQ 把当前消息从队列中标记清除。如果由于某些原因无法处理当前接受到的信息，可以通过 <code>channel.basicNack</code> 或则 <code>channel.basicReject</code> 来拒绝掉。</p><p>对于消费者来说，还有几点需要注意：</p><ul><li>消息分发</li><li>消息顺序性</li><li>弃用 QueueingConsumer</li></ul><h2 id="_2-消息分发" tabindex="-1"><a class="header-anchor" href="#_2-消息分发"><span>2. 消息分发</span></a></h2><p>当 RabbitMQ <strong>队列有多个消费者</strong> 时，队列收到的消息将以 <strong>轮询（round-robin）</strong> 方式分发给消费者，每条消息只会发送给订阅列表里的 <strong>一个消费者</strong>。这种方式是专门为并发程序设计的，如果程序处理不过来，只要增加更多的消费者来处理消息即可。</p><p>很多时候轮询的分发机制也有问题。默认情况下，如果有 n 个消费者，RabbitMQ 会将第 m 条消息分发给第 <code>m%n</code> (取余) 个消费者。RabbitMQ <strong>不管消费者是否消费并已经确认</strong>（Basic.Ack）消息。就可能会导致：某些消费者来不及处理消息，有些处理得很快的情况。</p><p>这种情况，需要 <strong>限制信道上</strong> 的消费者所能 <strong>保持的最大未确认消息的数量</strong>，通过 <code>channel.basicQos(int prefetchCount)</code> 方法。</p><p>举例说明：在订阅队列之前，消费者设置 <code>channel.basicQos(5)</code>，再订阅队列。 RabbitMQ 会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果到达了设置上限，就不会向这个消费者再发送任何消息。直到消费者确认了某条消费者之后，RabbitMQ 把对应的计数器 -1，继续分发消息。</p><p>注意要点：<code>Basic.Qos</code> 对拉模式无效</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">void</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> basicQos</span><span style="color:#E06C75;--shiki-dark:#E06C75;">(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">int</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> prefetchSize</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> int</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> prefetchCount</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> boolean</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> global) throws IOException</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><ul><li><p>prefetchSize：消费者所能接受未确认消息的总体大小的上限（单位为 B），设置为 0 时，表示无上限</p></li><li><p>prefetchCount：消费者所能接受最大未确认消息的数量</p></li><li><p>global：</p><p>一个信道可以消费多个队列</p><p>当该值大于 0 时，这个信道需要和各个队列协调，确保发送的消息都没有超过所限定的 prefetchCount。这会让 RabbitMQ 的性能降低，尤其当这些队列分散在集群中的多个 Broker 节点之中。为了解决这个性能问题，定义了 global 参数</p><table><thead><tr><th style="text-align:center;">global 参数</th><th>AMQP 0-9-1</th><th>RabbitMQ</th></tr></thead><tbody><tr><td style="text-align:center;">false</td><td>信道上所有的消费者都要遵从 prefetchCount 的限制</td><td>信道上所有的消费者都要遵从 prefetchCount 的限制</td></tr><tr><td style="text-align:center;">true</td><td>当前通信链路（Connection）上所有的消费者需要遵循从 prefetchCount 的限制</td><td>信道上所有的消费者都要遵从 prefetchCount 的限制（这里不知道书上是不是写错了？）</td></tr></tbody></table><p>channel.basicQos 只针对单个消费者的。对于同一个信道上的多个消费者而言，如果设置了 prefetchCount ，则都会生效。</p><p>如下代码，各自的能接收到的未确认消息上限都是 10</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">channel</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">basicQos</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">10</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">channel</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">basicConsume</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;queue1&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="color:#D19A66;--shiki-dark:#D19A66;">false</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,consumerl1)</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">channel</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">basicConsume</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;queue2&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="color:#D19A66;--shiki-dark:#D19A66;">false</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,consumerl2)</span></span></code></pre></div><p>如果同时设置了 global 为 false 和 true 呢？他们两个的限制都有效果：如下面这段代码</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">channel</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">basicQos</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">false</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">channel</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">basicQos</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">5</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">true</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">channel</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">basicConsume</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;queue1&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">false</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, consumerl1);</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">channel</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">basicConsume</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;queue2&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">false</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, consumerl2);</span></span></code></pre></div><p>那么生效情况如下：</p><ul><li>每个消费者最多可收到 3 个未确认的消息</li><li>两个消费者最多可收到 5 个未确认的消息</li></ul><p>这种设置方式，会增加 RabbitMQ 的负载，会使用更多的资源来协调完成这些限制。建议用默认值的 false。</p></li></ul><h2 id="_3-消息顺序性" tabindex="-1"><a class="header-anchor" href="#_3-消息顺序性"><span>3. 消息顺序性</span></a></h2><p>指：消费者 <strong>消费到的消息</strong> 和发送者 <strong>发布的消息</strong> 顺序是一致的。</p><p>如：发布 <code>1,2,3</code> 那么消费的顺序也是 <code>1,2,3</code></p><p>在 <strong>单个生产者和单个消费者的情况下，消息的有序性是能保证的</strong>，也是可验证的。在多消费者和多生产者的情况下，无法确定消息到达 Broker 的前后顺序，也无法确定客户端消费的顺序，这个其实是正常现象。分布式中本来就存在这样的现象。</p><p>有如下几种情况，消息的顺序性会被打破：但都是正常现象：</p><ul><li>使用事物机制时，发送失败，使用另一个线程补发此消息。此时消息就不能保证按照 <code>1,2,3,4</code> 的顺序到达 Broker 了</li><li>使用不同的消息过期时间，先过期的先被消费</li><li>使用优先级消息，优先级高的先被消费</li><li>客户端使用 <code>Basic.Nack/.Reject</code> 将消息拒绝时，同时 requeue= true， 消息重入队列后，也无法保证消息顺序还和发送的时候是一致的</li></ul><p>从以上点可以看到，在很多场景下，并不能保证消息的顺序性。</p><p>如果想要实现消息的有序性，则可以通过在消息体内增加全部有序标识，程序端自己实现逻辑判定</p><h2 id="_4-启用-queuingconsumer" tabindex="-1"><a class="header-anchor" href="#_4-启用-queuingconsumer"><span>4. 启用 QueuingConsumer</span></a></h2><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   ...</span></span>
<span class="line"><span style="color:#E06C75;--shiki-dark:#E06C75;">    queueingConsumer </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> QueueingConsumer</span><span style="color:#E06C75;--shiki-dark:#E06C75;">(channel)</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">    channel</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">basicConsume</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(replyQueue, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">true</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, queueingConsumer);</span></span>
<span class="line"><span style="color:#E06C75;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">public</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> String</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> call</span><span style="color:#E06C75;--shiki-dark:#E06C75;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">String</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> message) throws IOException</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> InterruptedException {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    final</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> String</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> corrid </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> UUID</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">randomUUID</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">().</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">toString</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    final</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> AMQP</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">BasicProperties</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> properties </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> AMQP</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">BasicProperties</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            .</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">builder</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            .</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">correlationId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(corrid)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            .</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">replyTo</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(replyQueue)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            .</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">build</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">    channel</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">basicPublish</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, requestQueue, properties, </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;message&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">getBytes</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 想服务端发送后，轮询，知道回去到服务端的响应为止</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    while</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> (</span><span style="color:#D19A66;--shiki-dark:#D19A66;">true</span><span style="color:#E06C75;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        final</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> QueueingConsumer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Delivery</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> delivery </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> queueingConsumer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">nextDelivery</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        if</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> (</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">delivery</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">getProperties</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">().</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">getCorrelationId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">().</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">equals</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(corrid)</span><span style="color:#E06C75;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">            return</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> String</span><span style="color:#E06C75;--shiki-dark:#E06C75;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">delivery</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">getBody</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">()</span><span style="color:#E06C75;--shiki-dark:#E06C75;">)</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="color:#E06C75;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面讲解 <a href="https://zq99299.github.io/mq-tutorial/rabbitmq-ac/04/06.html" target="_blank" rel="noopener noreferrer">RPC 实现</a> 中用到过这个类，如上的代码片段。在 RabbitMQ 4.x 中被标记为 <code>@Deprecated</code> 了。</p><p>是因为该类有几个大缺陷：比如内存溢出问题，由于某些原因，队列中堆积了比较多的消息，可能导致消费者客户端内存溢出假死，于是发生恶性循环，队列消息不断堆积而得不到消费。</p><p>导致内存溢出的原因是：QueuingConsumer 内部使用 LinkedBlockingQueue 来缓存消息，当设置的 <code>Basic.Qos</code> 数量太大的时候，消息体也很大（如一个消息 200M），那么就会导致内存溢出。可通过限制 qos 的数量来解决这个问题，但是一定 <strong>要在订阅之前设置</strong></p><p>QueuingConsumer 还包括以下缺陷（包括但不限于）：</p><ul><li>会拖累同一个 Connection 下的所有通道，使其性能降低</li><li>同步递归调用 QueuingConsumer 会产生死锁</li><li>RabbitMQ 的自动连接恢复机制（automatic Connection recovery） 不支持 QueuingConsumer 的这种形式</li><li>QueuingConsumer 不是事件驱动的</li></ul><p>所以还是使用 <code>DefaultConsumer</code> 之类的来订阅队列。</p><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章"><span>参考文章</span></a></h2><p><a href="https://zq99299.github.io/mq-tutorial/rabbitmq-ac/04/09.html" target="_blank" rel="noopener noreferrer">消费端要点介绍</a></p>`,31)]))}const t=a(l,[["render",r],["__file","rabbitmq-x-consumer.html.vue"]]),c=JSON.parse('{"path":"/posts/MiddleWare/MQ_Rabbitmq/rabbitmq-x-consumer.html","title":"RabbitMQ进阶 - 消费端要点介绍","lang":"zh-CN","frontmatter":{"aliases":"RabbitMQ进阶 - 消费端要点介绍","tags":null,"cssclass":null,"source":null,"order":110,"category":["RabbitMQ","MQ"],"created":"2024-02-22 10:50","updated":"2024-10-26 09:55","description":"RabbitMQ进阶 - 消费端要点介绍 1. 简介 消费者客户端可以通过 推模式 和 拉模式 来获取并消费消息，RabbitMQ 把消息推送后（或客户端主动 ACK）后，RabbitMQ 把当前消息从队列中标记清除。如果由于某些原因无法处理当前接受到的信息，可以通过 channel.basicNack 或则 channel.basicReject 来...","head":[["meta",{"property":"og:url","content":"https://mrjackc.github.io/posts/MiddleWare/MQ_Rabbitmq/rabbitmq-x-consumer.html"}],["meta",{"property":"og:site_name","content":"mrjason’s Blog"}],["meta",{"property":"og:title","content":"RabbitMQ进阶 - 消费端要点介绍"}],["meta",{"property":"og:description","content":"RabbitMQ进阶 - 消费端要点介绍 1. 简介 消费者客户端可以通过 推模式 和 拉模式 来获取并消费消息，RabbitMQ 把消息推送后（或客户端主动 ACK）后，RabbitMQ 把当前消息从队列中标记清除。如果由于某些原因无法处理当前接受到的信息，可以通过 channel.basicNack 或则 channel.basicReject 来..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-28T01:58:08.000Z"}],["meta",{"property":"article:author","content":"MrJason"}],["meta",{"property":"article:modified_time","content":"2024-10-28T01:58:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ进阶 - 消费端要点介绍\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-28T01:58:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MrJason\\",\\"url\\":\\"https://mrjackc.github.io\\"}]}"]]},"headers":[{"level":2,"title":"1. 简介","slug":"_1-简介","link":"#_1-简介","children":[]},{"level":2,"title":"2. 消息分发","slug":"_2-消息分发","link":"#_2-消息分发","children":[]},{"level":2,"title":"3. 消息顺序性","slug":"_3-消息顺序性","link":"#_3-消息顺序性","children":[]},{"level":2,"title":"4. 启用 QueuingConsumer","slug":"_4-启用-queuingconsumer","link":"#_4-启用-queuingconsumer","children":[]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1730080688000,"updatedTime":1730080688000,"contributors":[{"name":"MrJason","email":"845886914@qq.com","commits":1}]},"readingTime":{"minutes":5.66,"words":1698},"filePathRelative":"posts/MiddleWare/MQ_Rabbitmq/rabbitmq-x-consumer.md","localizedDate":"2024年10月28日","excerpt":"\\n<h2>1. 简介</h2>\\n<p>消费者客户端可以通过 <strong>推模式</strong> 和 <strong>拉模式</strong> 来获取并消费消息，RabbitMQ 把消息推送后（或客户端主动 ACK）后，RabbitMQ 把当前消息从队列中标记清除。如果由于某些原因无法处理当前接受到的信息，可以通过 <code>channel.basicNack</code> 或则 <code>channel.basicReject</code> 来拒绝掉。</p>\\n<p>对于消费者来说，还有几点需要注意：</p>\\n<ul>\\n<li>消息分发</li>\\n<li>消息顺序性</li>\\n<li>弃用 QueueingConsumer</li>\\n</ul>","autoDesc":true}');export{t as comp,c as data};
