import{_ as i,c as e,a,o as n}from"./app-BOcQBfH9.js";const l={};function t(r,s){return n(),e("div",null,s[0]||(s[0]=[a(`<h1 id="redis进阶-数据类型-对象机制详解" tabindex="-1"><a class="header-anchor" href="#redis进阶-数据类型-对象机制详解"><span>Redis进阶 - 数据类型：对象机制详解</span></a></h1><h2 id="_1-引入-从哪里开始学习底层" tabindex="-1"><a class="header-anchor" href="#_1-引入-从哪里开始学习底层"><span>1. 引入:从哪里开始学习底层？</span></a></h2><blockquote><p>我在整理Redis底层设计时，发现网上其实是有很多资料的，但是缺少一种自上而下的承接。这里我将收集很多网上的资料并重新组织，来帮助你更好的理解Redis底层设计。</p></blockquote><p>我们在前文已经阐述了<a href="https://java.isture.com/redis/started/Redis%E5%85%A5%E9%97%A8-5%E7%A7%8D%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener noreferrer">Redis 5种基础数据类型详解</a>和<a href="https://java.isture.com/redis/started/Redis%E5%85%A5%E9%97%A8Stream%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener noreferrer">Redis入门 - 数据结构：Stream详解</a>；那么这些基础类型的底层是如何实现的呢？</p><p>带着这个问题我们来着手理解底层设计，首先看下图：</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403131023189.png" alt="image-20220623205912495" tabindex="0" loading="lazy"><figcaption>image-20220623205912495</figcaption></figure><p>它反映了Redis的每种对象其实都由<strong>对象结构(redisObject)</strong> 与 <strong>对应编码的数据结构</strong>组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。</p><p>所以，我们需要从几个个角度来着手底层研究：</p><ul><li><strong>对象设计机制</strong>: 对象结构(redisObject)</li><li><strong>编码类型和底层数据结构</strong>: 对应编码的数据结构</li></ul><h2 id="_2-为什么redis会设计redisobject对象" tabindex="-1"><a class="header-anchor" href="#_2-为什么redis会设计redisobject对象"><span>2. 为什么Redis会设计redisObject对象</span></a></h2><blockquote><p>为什么Redis会设计redisObject对象？</p></blockquote><p>在redis的命令中，用于对键进行处理的命令占了很大一部分，而对于键所保存的值的类型（键的类型），键能执行的命令又各不相同。如： <code>LPUSH</code> 和 <code>LLEN</code> 只能用于列表键, 而 <code>SADD</code> 和 <code>SRANDMEMBER</code> 只能用于集合键, 等等; 另外一些命令, 比如 <code>DEL</code>、 <code>TTL</code> 和 <code>TYPE</code>, 可以用于任何类型的键；但是要正确实现这些命令, 必须为不同类型的键设置不同的处理方式: 比如说, 删除一个列表键和删除一个字符串键的操作过程就不太一样。</p><p>以上的描述说明, <strong>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式</strong>.</p><p>比如说， 集合类型就可以由字典和整数集合两种不同的数据结构实现， 但是， 当用户执行 ZADD 命令时， 他/她应该不必关心集合使用的是什么编码， 只要 Redis 能按照 ZADD 命令的指示， 将新元素添加到集合就可以了。</p><p>这说明, <strong>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理</strong>.</p><p>为了解决以上问题, <strong>Redis 构建了自己的类型系统</strong>, 这个系统的主要功能包括:</p><ul><li>redisObject 对象.</li><li>基于 redisObject 对象的类型检查.</li><li>基于 redisObject 对象的显式多态函数.</li><li>对 redisObject 进行分配、共享和销毁的机制</li></ul><h2 id="_3-redisobject数据结构" tabindex="-1"><a class="header-anchor" href="#_3-redisobject数据结构"><span>3. redisObject数据结构</span></a></h2><p>redisObject 是 Redis 类型系统的核心, 数据库中的每个键、值, 以及 Redis 本身处理的参数, 都表示为这种数据类型.</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/*</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * Redis 对象</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> redisObject {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 类型</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    unsigned</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> type:</span><span style="color:#D19A66;--shiki-dark:#D19A66;">4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 编码方式</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    unsigned</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> encoding:</span><span style="color:#D19A66;--shiki-dark:#D19A66;">4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    unsigned</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> lru:LRU_BITS;</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // LRU_BITS: 24</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 引用计数</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> refcount;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 指向底层数据结构实例</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    void</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">ptr;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} robj;</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图对应上面的结构</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403131023233.png" alt="image-20220623211402720" tabindex="0" loading="lazy"><figcaption>image-20220623211402720</figcaption></figure><p><strong>其中type、encoding和ptr是最重要的三个属性</strong>。</p><ul><li><strong>type记录了对象所保存的值的类型</strong>，它的值可能是以下常量中的一个：</li></ul><div class="language-c" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/*</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">* 对象类型</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">*/</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_STRING</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 0</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 字符串</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_LIST</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 1</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 列表</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_SET</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 2</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 集合</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ZSET</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 3</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 有序集</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_HASH</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 4</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 哈希表</span></span></code></pre></div><ul><li><strong>encoding记录了对象所保存的值的编码</strong>，它的值可能是以下常量中的一个：</li></ul><div class="language-c" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/*</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">* 对象编码</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">*/</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ENCODING_RAW</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 0</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     /* Raw representation */</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ENCODING_INT</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 1</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     /* Encoded as integer */</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ENCODING_HT</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 2</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      /* Encoded as hash table */</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ENCODING_ZIPMAP</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 3</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /* 注意：版本2.6后不再使用. */</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ENCODING_LINKEDLIST</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 4</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> /* 注意：不再使用了，旧版本2.x中String的底层之一. */</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ENCODING_ZIPLIST</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 5</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> /* Encoded as ziplist */</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ENCODING_INTSET</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 6</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /* Encoded as intset */</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ENCODING_SKIPLIST</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 7</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /* Encoded as skiplist */</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ENCODING_EMBSTR</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 8</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /* Embedded sds string encoding */</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ENCODING_QUICKLIST</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 9</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> /* Encoded as linked list of ziplists */</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> OBJ_ENCODING_STREAM</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 10</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> /* Encoded as a radix tree of listpacks */</span></span></code></pre></div><ul><li><strong>ptr是一个指针，指向实际保存值的数据结构</strong>，这个数据结构由type和encoding属性决定。举个例子， 如果一个redisObject 的type 属性为<code>OBJ_LIST</code> ， encoding 属性为<code>OBJ_ENCODING_QUICKLIST</code> ，那么这个对象就是一个Redis 列表（List)，它的值保存在一个QuickList的数据结构内，而ptr 指针就指向quicklist的对象；</li></ul><p>下图展示了redisObject 、Redis 所有数据类型、Redis 所有编码方式以及底层数据结构之间的关系（从6.0版本中梳理而来）：</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403131023265.png" alt="image-20220623212428823" tabindex="0" loading="lazy"><figcaption>image-20220623212428823</figcaption></figure><blockquote><p>注意：<code>OBJ_ENCODING_ZIPMAP</code>没有出现在图中，因为在redis2.6开始，它不再是任何数据类型的底层结构(虽然还有zipmap.c的代码); <code>OBJ_ENCODING_LINKEDLIST</code>也不支持了，相关代码也删除了。</p></blockquote><ul><li><strong>lru属性: 记录了对象最后一次被命令程序访问的时间</strong></li></ul><p><strong>空转时长</strong>：当前时间减去键的值对象的lru时间，就是该键的空转时长。Object idletime命令可以打印出给定键的空转时长</p><p>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p><h2 id="_4-命令的类型检查和多态" tabindex="-1"><a class="header-anchor" href="#_4-命令的类型检查和多态"><span>4. 命令的类型检查和多态</span></a></h2><blockquote><p>那么Redis是如何处理一条命令的呢？</p></blockquote><p><strong>当执行一个处理数据类型命令的时候，redis执行以下步骤</strong></p><ul><li>根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；</li><li>检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；</li><li>根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；</li><li>返回数据结构的操作结果作为命令的返回值。</li></ul><p>比如现在执行LPOP命令：</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/image-20220623212517535.png" alt="image-20220623212517535" tabindex="0" loading="lazy"><figcaption>image-20220623212517535</figcaption></figure><h2 id="_5-对象共享" tabindex="-1"><a class="header-anchor" href="#_5-对象共享"><span>5. 对象共享</span></a></h2><blockquote><p>redis一般会把一些常见的值放到一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。</p></blockquote><p><strong>redis预分配的值对象如下</strong>：</p><ul><li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li><li>包括0 在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403131023299.png" alt="image-20220623212558850" tabindex="0" loading="lazy"><figcaption>image-20220623212558850</figcaption></figure><blockquote><p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等自勉之的内存数据结构</p></blockquote><p><strong>为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象</strong>？</p><ul><li>列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高。</li><li>如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)</li><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)</li><li>如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N的平方)</li></ul><p>如果对复杂度较高的对象创建共享对象，需要消耗很大的CPU，用这种消耗去换取内存空间，是不合适的</p><h2 id="_6-引用计数以及对象的消毁" tabindex="-1"><a class="header-anchor" href="#_6-引用计数以及对象的消毁"><span>6. 引用计数以及对象的消毁</span></a></h2><blockquote><p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p></blockquote><ul><li>每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；</li><li>当新创建一个对象时，它的refcount属性被设置为1；</li><li>当对一个对象进行共享时，redis将这个对象的refcount加一；</li><li>当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一；</li><li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。</li></ul><h2 id="_7-小结" tabindex="-1"><a class="header-anchor" href="#_7-小结"><span>7. 小结</span></a></h2><ul><li>redis使用自己实现的对象机制（redisObject)来实现类型判断、命令多态和基于引用次数的垃圾回收；</li><li>redis会预分配一些常用的数据对象，并通过共享这些对象来减少内存占用，和避免频繁的为小对象分配内存。</li></ul><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章"><span>参考文章</span></a></h2><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-object.html" target="_blank" rel="noopener noreferrer"><strong>Redis进阶 - 数据结构：对象机制详解</strong></a></p>`,56)]))}const d=i(l,[["render",t],["__file","db-redis-x-redis-object.html.vue"]]),c=JSON.parse('{"path":"/posts/Redis/db-redis-x-redis-object.html","title":"Redis进阶 - 数据类型：对象机制详解","lang":"zh-CN","frontmatter":{"aliases":"Redis进阶 - 数据类型：对象机制详解","tags":null,"cssclass":null,"source":null,"order":110,"category":["数据库","Redis"],"created":"2024-02-22 10:49","updated":"2024-03-13 10:23","description":"Redis进阶 - 数据类型：对象机制详解 1. 引入:从哪里开始学习底层？ 我在整理Redis底层设计时，发现网上其实是有很多资料的，但是缺少一种自上而下的承接。这里我将收集很多网上的资料并重新组织，来帮助你更好的理解Redis底层设计。 我们在前文已经阐述了Redis 5种基础数据类型详解和Redis入门 - 数据结构：Stream详解；那么这些基...","head":[["meta",{"property":"og:url","content":"https://mrjackc.github.io/posts/Redis/db-redis-x-redis-object.html"}],["meta",{"property":"og:site_name","content":"mrjason’s Blog"}],["meta",{"property":"og:title","content":"Redis进阶 - 数据类型：对象机制详解"}],["meta",{"property":"og:description","content":"Redis进阶 - 数据类型：对象机制详解 1. 引入:从哪里开始学习底层？ 我在整理Redis底层设计时，发现网上其实是有很多资料的，但是缺少一种自上而下的承接。这里我将收集很多网上的资料并重新组织，来帮助你更好的理解Redis底层设计。 我们在前文已经阐述了Redis 5种基础数据类型详解和Redis入门 - 数据结构：Stream详解；那么这些基..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403131023189.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-21T07:03:09.000Z"}],["meta",{"property":"article:author","content":"MrJason"}],["meta",{"property":"article:modified_time","content":"2024-10-21T07:03:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis进阶 - 数据类型：对象机制详解\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403131023189.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403131023233.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403131023265.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/image-20220623212517535.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403131023299.png\\"],\\"dateModified\\":\\"2024-10-21T07:03:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MrJason\\",\\"url\\":\\"https://mrjackc.github.io\\"}]}"]]},"headers":[{"level":2,"title":"1. 引入:从哪里开始学习底层？","slug":"_1-引入-从哪里开始学习底层","link":"#_1-引入-从哪里开始学习底层","children":[]},{"level":2,"title":"2. 为什么Redis会设计redisObject对象","slug":"_2-为什么redis会设计redisobject对象","link":"#_2-为什么redis会设计redisobject对象","children":[]},{"level":2,"title":"3. redisObject数据结构","slug":"_3-redisobject数据结构","link":"#_3-redisobject数据结构","children":[]},{"level":2,"title":"4. 命令的类型检查和多态","slug":"_4-命令的类型检查和多态","link":"#_4-命令的类型检查和多态","children":[]},{"level":2,"title":"5. 对象共享","slug":"_5-对象共享","link":"#_5-对象共享","children":[]},{"level":2,"title":"6. 引用计数以及对象的消毁","slug":"_6-引用计数以及对象的消毁","link":"#_6-引用计数以及对象的消毁","children":[]},{"level":2,"title":"7. 小结","slug":"_7-小结","link":"#_7-小结","children":[]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1729494189000,"updatedTime":1729494189000,"contributors":[{"name":"MrJason","email":"845886914@qq.com","commits":1}]},"readingTime":{"minutes":7.98,"words":2393},"filePathRelative":"posts/Redis/db-redis-x-redis-object.md","localizedDate":"2024年10月21日","excerpt":"\\n<h2>1. 引入:从哪里开始学习底层？</h2>\\n<blockquote>\\n<p>我在整理Redis底层设计时，发现网上其实是有很多资料的，但是缺少一种自上而下的承接。这里我将收集很多网上的资料并重新组织，来帮助你更好的理解Redis底层设计。</p>\\n</blockquote>\\n<p>我们在前文已经阐述了<a href=\\"https://java.isture.com/redis/started/Redis%E5%85%A5%E9%97%A8-5%E7%A7%8D%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Redis 5种基础数据类型详解</a>和<a href=\\"https://java.isture.com/redis/started/Redis%E5%85%A5%E9%97%A8Stream%E8%AF%A6%E8%A7%A3.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Redis入门 - 数据结构：Stream详解</a>；那么这些基础类型的底层是如何实现的呢？</p>","autoDesc":true}');export{d as comp,c as data};
