import{_ as a,c as o,a as r,o as s}from"./app-4x2aIoqi.js";const i={};function n(t,e){return s(),o("div",null,e[0]||(e[0]=[r(`<h1 id="redis-缓存" tabindex="-1"><a class="header-anchor" href="#redis-缓存"><span>Redis 缓存</span></a></h1><p><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-redis/" target="_blank" rel="noopener noreferrer"><code>yudao-spring-boot-starter-redis</code> (opens new window)</a>技术组件，使用 Redis 实现缓存的功能，它有 2 种使用方式：</p><ul><li>编程式缓存：基于 Spring Data Redis 框架的 RedisTemplate 操作模板</li><li>声明式缓存：基于 Spring Cache 框架的 <code>@Cacheable</code> 等等注解</li></ul><h2 id="_1-编程式缓存" tabindex="-1"><a class="header-anchor" href="#_1-编程式缓存"><span><a href="https://doc.iocoder.cn/redis-cache/#_1-%E7%BC%96%E7%A8%8B%E5%BC%8F%E7%BC%93%E5%AD%98" target="_blank" rel="noopener noreferrer">#</a>1. 编程式缓存</span></a></h2><p>友情提示：</p><p>如果你未学习过 Spring Data Redis 框架，可以后续阅读 <a href="http://www.iocoder.cn/Spring-Boot/Redis/?yudao" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot Redis 入门》 (opens new window)</a>文章。</p><div class="language-xml" data-ext="xml" data-title="xml"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">dependency</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">groupId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;org.redisson&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">groupId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">artifactId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;redisson-spring-boot-starter&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">artifactId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">dependency</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre></div><p>由于 Redisson 提供了分布式锁、队列、限流等特性，所以使用它作为 Spring Data Redis 的客户端。</p><h3 id="_1-1-spring-data-redis-配置" tabindex="-1"><a class="header-anchor" href="#_1-1-spring-data-redis-配置"><span><a href="https://doc.iocoder.cn/redis-cache/#_1-1-spring-data-redis-%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener noreferrer">#</a>1.1 Spring Data Redis 配置</span></a></h3><p>① 在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-server/src/main/resources/application-local.yaml#L60-L64" target="_blank" rel="noopener noreferrer"><code>application-local.yaml</code> (opens new window)</a>配置文件中，通过 <code>spring.redis</code> 配置项，设置 Redis 的配置。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/01.png" alt="Spring Data Redis 配置" tabindex="0" loading="lazy"><figcaption>Spring Data Redis 配置</figcaption></figure><p>② 在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-redis/src/main/java/cn/iocoder/yudao/framework/redis/config/YudaoRedisAutoConfiguration.java" target="_blank" rel="noopener noreferrer">YudaoRedisAutoConfiguration (opens new window)</a>配置类，设置使用 JSON 序列化 value 值。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/02.png" alt="YudaoRedisAutoConfiguration 配置类" tabindex="0" loading="lazy"><figcaption>YudaoRedisAutoConfiguration 配置类</figcaption></figure><h3 id="_1-2-实战案例" tabindex="-1"><a class="header-anchor" href="#_1-2-实战案例"><span><a href="https://doc.iocoder.cn/redis-cache/#_1-2-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B" target="_blank" rel="noopener noreferrer">#</a>1.2 实战案例</span></a></h3><p>以访问令牌 Access Token 的缓存来举例子，讲解项目中是如何使用 Spring Data Redis 框架的。</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/07.png" alt="Access Token 示例" tabindex="0" loading="lazy"><figcaption>Access Token 示例</figcaption></figure><h4 id="_1-2-1-引入依赖" tabindex="-1"><a class="header-anchor" href="#_1-2-1-引入依赖"><span><a href="https://doc.iocoder.cn/redis-cache/#_1-2-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96" target="_blank" rel="noopener noreferrer">#</a>1.2.1 引入依赖</span></a></h4><p>在 <code>yudao-module-system-biz</code> 模块中，引入 <code>yudao-spring-boot-starter-redis</code> 技术组件。如下所示：</p><div class="language-xml" data-ext="xml" data-title="xml"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">dependency</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">groupId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;cn.iocoder.boot&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">groupId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">artifactId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;yudao-spring-boot-starter-redis&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">artifactId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">dependency</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre></div><h4 id="_1-2-2-oauth2accesstokendo" tabindex="-1"><a class="header-anchor" href="#_1-2-2-oauth2accesstokendo"><span><a href="https://doc.iocoder.cn/redis-cache/#_1-2-2-oauth2accesstokendo" target="_blank" rel="noopener noreferrer">#</a>1.2.2 OAuth2AccessTokenDO</span></a></h4><p>新建 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/dal/dataobject/oauth2/OAuth2AccessTokenDO.java" target="_blank" rel="noopener noreferrer">OAuth2AccessTokenDO (opens new window)</a>类，访问令牌 Access Token 类。代码如下：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/03.png" alt="OAuth2AccessTokenDO 类" tabindex="0" loading="lazy"><figcaption>OAuth2AccessTokenDO 类</figcaption></figure><p>友情提示：</p><ul><li>① 如果值是【简单】的 String 或者 Integer 等类型，无需创建数据实体。</li><li>② 如果值是【复杂对象】时，建议在 <code>dal/dataobject</code> 包下，创建对应的数据实体。</li></ul><h4 id="_1-2-3-rediskeyconstants" tabindex="-1"><a class="header-anchor" href="#_1-2-3-rediskeyconstants"><span><a href="https://doc.iocoder.cn/redis-cache/#_1-2-3-rediskeyconstants" target="_blank" rel="noopener noreferrer">#</a>1.2.3 RedisKeyConstants</span></a></h4><p>为什么要定义 Redis Key 常量？</p><p>每个 <code>yudao-module-xxx</code> 模块，都有一个 RedisKeyConstants 类，定义该模块的 Redis Key 的信息。目的是，避免 Redis Key 散落在 Service 业务代码中，像对待数据库的表一样，对待每个 Redis Key。通过这样的方式，如果我们想要了解一个模块的 Redis 的使用情况，只需要查看 RedisKeyConstants 类即可。</p><p>在 <code>yudao-module-system</code> 模块的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/dal/redis/RedisKeyConstants.java" target="_blank" rel="noopener noreferrer">RedisKeyConstants (opens new window)</a>类中，新建 OAuth2AccessTokenDO 对应的 Redis Key 定义 <code>OAUTH2_ACCESS_TOKEN</code>。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/04.png" alt="RedisKeyConstants 类" tabindex="0" loading="lazy"><figcaption>RedisKeyConstants 类</figcaption></figure><h4 id="_1-2-4-oauth2accesstokenredisdao" tabindex="-1"><a class="header-anchor" href="#_1-2-4-oauth2accesstokenredisdao"><span><a href="https://doc.iocoder.cn/redis-cache/#_1-2-4-oauth2accesstokenredisdao" target="_blank" rel="noopener noreferrer">#</a>1.2.4 OAuth2AccessTokenRedisDAO</span></a></h4><p>新建 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/dal/redis/oauth2/OAuth2AccessTokenRedisDAO.java" target="_blank" rel="noopener noreferrer">OAuth2AccessTokenRedisDAO (opens new window)</a>类，是 OAuth2AccessTokenDO 的 RedisDAO 实现。代码如下：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/05.png" alt="OAuth2AccessTokenRedisDAO 类" tabindex="0" loading="lazy"><figcaption>OAuth2AccessTokenRedisDAO 类</figcaption></figure><h4 id="_1-2-5-oauth2tokenserviceimpl" tabindex="-1"><a class="header-anchor" href="#_1-2-5-oauth2tokenserviceimpl"><span><a href="https://doc.iocoder.cn/redis-cache/#_1-2-5-oauth2tokenserviceimpl" target="_blank" rel="noopener noreferrer">#</a>1.2.5 OAuth2TokenServiceImpl</span></a></h4><p>在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/oauth2/OAuth2TokenServiceImpl.java" target="_blank" rel="noopener noreferrer">OAuth2TokenServiceImpl (opens new window)</a>中，只要注入 OAuth2AccessTokenRedisDAO Bean，非常简洁干净的进行 OAuth2AccessTokenDO 的缓存操作，无需关心具体的实现。代码如下：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/06.png" alt="OAuth2TokenServiceImpl 类" tabindex="0" loading="lazy"><figcaption>OAuth2TokenServiceImpl 类</figcaption></figure><h2 id="_2-声明式缓存" tabindex="-1"><a class="header-anchor" href="#_2-声明式缓存"><span><a href="https://doc.iocoder.cn/redis-cache/#_2-%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%93%E5%AD%98" target="_blank" rel="noopener noreferrer">#</a>2. 声明式缓存</span></a></h2><p>友情提示：</p><p>如果你未学习过 Spring Cache 框架，可以后续阅读 <a href="http://www.iocoder.cn/Spring-Boot/Cache/?yudao" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot Cache 入门》 (opens new window)</a>文章。</p><div class="language-xml" data-ext="xml" data-title="xml"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">dependency</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">groupId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;org.springframework.boot&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">groupId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">artifactId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;spring-boot-starter-cache&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">artifactId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">dependency</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre></div><p>相比来说 Spring Data Redis 编程式缓存，Spring Cache 声明式缓存的使用更加便利，一个 <code>@Cacheable</code> 注解即可实现缓存的功能。示例如下：</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">@</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Cacheable</span><span style="color:#E06C75;--shiki-dark:#E06C75;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">value</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#98C379;--shiki-dark:#98C379;"> &quot;users&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> key</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#98C379;--shiki-dark:#98C379;"> &quot;#id&quot;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">UserDO</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> getUserById</span><span style="color:#E06C75;--shiki-dark:#E06C75;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Integer</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> id)</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><h3 id="_2-1-spring-cache-配置" tabindex="-1"><a class="header-anchor" href="#_2-1-spring-cache-配置"><span><a href="https://doc.iocoder.cn/redis-cache/#_2-1-spring-cache-%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener noreferrer">#</a>2.1 Spring Cache 配置</span></a></h3><p>① 在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-server/src/main/resources/application.yaml#L60-L64" target="_blank" rel="noopener noreferrer"><code>application.yaml</code> (opens new window)</a>配置文件中，通过 <code>spring.redis</code> 配置项，设置 Redis 的配置。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/10.png" alt="Spring Cache 配置" tabindex="0" loading="lazy"><figcaption>Spring Cache 配置</figcaption></figure><p>② 在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-redis/src/main/java/cn/iocoder/yudao/framework/redis/config/YudaoCacheAutoConfiguration.java" target="_blank" rel="noopener noreferrer">YudaoCacheAutoConfiguration (opens new window)</a>配置类，设置使用 JSON 序列化 value 值。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/11.png" alt="YudaoCacheAutoConfiguration 配置类" tabindex="0" loading="lazy"><figcaption>YudaoCacheAutoConfiguration 配置类</figcaption></figure><h3 id="_2-2-常见注解" tabindex="-1"><a class="header-anchor" href="#_2-2-常见注解"><span><a href="https://doc.iocoder.cn/redis-cache/#_2-2-%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3" target="_blank" rel="noopener noreferrer">#</a>2.2 常见注解</span></a></h3><h4 id="_2-2-1-cacheable-注解" tabindex="-1"><a class="header-anchor" href="#_2-2-1-cacheable-注解"><span><a href="https://doc.iocoder.cn/redis-cache/#_2-2-1-cacheable-%E6%B3%A8%E8%A7%A3" target="_blank" rel="noopener noreferrer">#</a>2.2.1 @Cacheable 注解</span></a></h4><p><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-context/src/main/java/org/springframework/cache/annotation/Cacheable.java" target="_blank" rel="noopener noreferrer"><code>@Cacheable</code> (opens new window)</a>注解：添加在方法上，缓存方法的执行结果。执行过程如下：</p><ul><li>1）首先，判断方法执行结果的缓存。如果有，则直接返回该缓存结果。</li><li>2）然后，执行方法，获得方法结果。</li><li>3）之后，根据是否满足缓存的条件。如果满足，则缓存方法结果到缓存。</li><li>4）最后，返回方法结果。</li></ul><h4 id="_2-2-2-cacheput-注解" tabindex="-1"><a class="header-anchor" href="#_2-2-2-cacheput-注解"><span><a href="https://doc.iocoder.cn/redis-cache/#_2-2-2-cacheput-%E6%B3%A8%E8%A7%A3" target="_blank" rel="noopener noreferrer">#</a>2.2.2 @CachePut 注解</span></a></h4><p><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-context/src/main/java/org/springframework/cache/annotation/CachePut.java" target="_blank" rel="noopener noreferrer"><code>@CachePut</code> (opens new window)</a>注解，添加在方法上，缓存方法的执行结果。不同于 <code>@Cacheable</code> 注解，它的执行过程如下：</p><ul><li>1）首先，执行方法，获得方法结果。也就是说，无论是否有缓存，都会执行方法。</li><li>2）然后，根据是否满足缓存的条件。如果满足，则缓存方法结果到缓存。</li><li>3）最后，返回方法结果。</li></ul><h4 id="_2-2-3-cacheevict-注解" tabindex="-1"><a class="header-anchor" href="#_2-2-3-cacheevict-注解"><span><a href="https://doc.iocoder.cn/redis-cache/#_2-2-3-cacheevict-%E6%B3%A8%E8%A7%A3" target="_blank" rel="noopener noreferrer">#</a>2.2.3 @CacheEvict 注解</span></a></h4><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/cache/annotation/CacheEvict.java" target="_blank" rel="noopener noreferrer"><code>@CacheEvict</code> (opens new window)</a>注解，添加在方法上，删除缓存。</p><h3 id="_2-3-实战案例" tabindex="-1"><a class="header-anchor" href="#_2-3-实战案例"><span><a href="https://doc.iocoder.cn/redis-cache/#_2-3-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B" target="_blank" rel="noopener noreferrer">#</a>2.3 实战案例</span></a></h3><p>在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/permission/RoleServiceImpl.java" target="_blank" rel="noopener noreferrer">RoleServiceImpl (opens new window)</a>中，使用 Spring Cache 实现了 Role 角色缓存，采用【被动读】的方案。原因是：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/12.png" alt="RoleServiceImpl" tabindex="0" loading="lazy"><figcaption>RoleServiceImpl</figcaption></figure><ul><li>【被动读】相对能够保证 Redis 与 MySQL 的一致性</li><li>绝大数数据不需要放到 Redis 缓存中，采用【主动写】会将非必要的数据进行缓存</li></ul><p>友情提示：</p><p>如果你未学习过 MySQL 与 Redis 一致性的问题，可以后续阅读 <a href="https://www.iocoder.cn/Fight/How-Redis-and-MySQL-double-write-consistency-guarantee/?yudao" target="_blank" rel="noopener noreferrer">《Redis 与 MySQL 双写一致性如何保证？ 》 (opens new window)</a>文章。</p><p>① 执行 <code>#getRoleFromCache(...)</code> 方法，从 MySQL 读取数据后，向 Redis 写入缓存。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/13.png" alt="getTestDemo 方法" tabindex="0" loading="lazy"><figcaption>getTestDemo 方法</figcaption></figure><p>② 执行 <code>#updateRole(...)</code> 或 <code>#deleteRole(...)</code> 方法，在更新或者删除 MySQL 数据后，从 Redis 删除缓存。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/14.png" alt="getTestDemo 方法" tabindex="0" loading="lazy"><figcaption>getTestDemo 方法</figcaption></figure><h3 id="_2-4-过期时间" tabindex="-1"><a class="header-anchor" href="#_2-4-过期时间"><span><a href="https://doc.iocoder.cn/redis-cache/#_2-4-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4" target="_blank" rel="noopener noreferrer">#</a>2.4 过期时间</span></a></h3><p>Spring Cache 默认使用 <code>spring.cache.redis.time-to-live</code> 配置项，设置缓存的过期时间，项目默认为 1 小时。</p><p>如果你想自定义过期时间，可以在 <code>@Cacheable</code> 注解中的 <code>cacheNames</code> 属性中，添加 <code>#{过期时间}</code> 后缀，单位是秒。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/过期时间.png" alt="过期时间" tabindex="0" loading="lazy"><figcaption>过期时间</figcaption></figure><p>实现的原来，参考 <a href="https://juejin.cn/post/7102222578026020871" target="_blank" rel="noopener noreferrer">《Spring @Cacheable 扩展支持自定义过期时间 》 (opens new window)</a>文章。</p><h2 id="_3-redis-监控" tabindex="-1"><a class="header-anchor" href="#_3-redis-监控"><span><a href="https://doc.iocoder.cn/redis-cache/#_3-redis-%E7%9B%91%E6%8E%A7" target="_blank" rel="noopener noreferrer">#</a>3. Redis 监控</span></a></h2><p><code>yudao-module-infra</code> 的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-infra/yudao-module-infra-biz/src/main/java/cn/iocoder/yudao/module/infra/controller/admin/redis/RedisController.java" target="_blank" rel="noopener noreferrer"><code>redis</code> (opens new window)</a>模块，提供了 Redis 监控的功能。</p><p>点击 [基础设施 -&gt; Redis 监控] 菜单，可以查看到 Redis 的基础信息、命令统计、内存信息。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/Redis缓存/21.png" alt="Redis 监控" tabindex="0" loading="lazy"><figcaption>Redis 监控</figcaption></figure><p>上次更新: 2023/04/07, 23:30:07</p>`,75)]))}const d=a(i,[["render",n],["__file","19.Redis 缓存.html.vue"]]),p=JSON.parse('{"path":"/posts/Java/Ruoyi-Vue-Pro/2.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/19.Redis%20%E7%BC%93%E5%AD%98.html","title":"Redis 缓存","lang":"zh-CN","frontmatter":{"description":"Redis 缓存 yudao-spring-boot-starter-redis (opens new window)技术组件，使用 Redis 实现缓存的功能，它有 2 种使用方式： 编程式缓存：基于 Spring Data Redis 框架的 RedisTemplate 操作模板 声明式缓存：基于 Spring Cache 框架的 @Cacheab...","watermark":true,"head":[["meta",{"property":"og:url","content":"https://springg.us.kg/posts/Java/Ruoyi-Vue-Pro/2.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/19.Redis%20%E7%BC%93%E5%AD%98.html"}],["meta",{"property":"og:site_name","content":"mrjason’s Blog"}],["meta",{"property":"og:title","content":"Redis 缓存"}],["meta",{"property":"og:description","content":"Redis 缓存 yudao-spring-boot-starter-redis (opens new window)技术组件，使用 Redis 实现缓存的功能，它有 2 种使用方式： 编程式缓存：基于 Spring Data Redis 框架的 RedisTemplate 操作模板 声明式缓存：基于 Spring Cache 框架的 @Cacheab..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/01.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-21T07:41:53.000Z"}],["meta",{"property":"article:author","content":"MrJason"}],["meta",{"property":"article:modified_time","content":"2024-11-21T07:41:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis 缓存\\",\\"image\\":[\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/01.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/02.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/07.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/03.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/04.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/05.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/06.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/10.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/11.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/12.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/13.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/14.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4.png\\",\\"https://doc.iocoder.cn/img/Redis%E7%BC%93%E5%AD%98/21.png\\"],\\"dateModified\\":\\"2024-11-21T07:41:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MrJason\\",\\"url\\":\\"https://springg.us.kg\\"}]}"]]},"headers":[{"level":2,"title":"#1. 编程式缓存","slug":"_1-编程式缓存","link":"#_1-编程式缓存","children":[{"level":3,"title":"#1.1 Spring Data Redis 配置","slug":"_1-1-spring-data-redis-配置","link":"#_1-1-spring-data-redis-配置","children":[]},{"level":3,"title":"#1.2 实战案例","slug":"_1-2-实战案例","link":"#_1-2-实战案例","children":[]}]},{"level":2,"title":"#2. 声明式缓存","slug":"_2-声明式缓存","link":"#_2-声明式缓存","children":[{"level":3,"title":"#2.1 Spring Cache 配置","slug":"_2-1-spring-cache-配置","link":"#_2-1-spring-cache-配置","children":[]},{"level":3,"title":"#2.2 常见注解","slug":"_2-2-常见注解","link":"#_2-2-常见注解","children":[]},{"level":3,"title":"#2.3 实战案例","slug":"_2-3-实战案例","link":"#_2-3-实战案例","children":[]},{"level":3,"title":"#2.4 过期时间","slug":"_2-4-过期时间","link":"#_2-4-过期时间","children":[]}]},{"level":2,"title":"#3. Redis 监控","slug":"_3-redis-监控","link":"#_3-redis-监控","children":[]}],"git":{"createdTime":1732174913000,"updatedTime":1732174913000,"contributors":[{"name":"MrJason","email":"845886914@qq.com","commits":1}]},"readingTime":{"minutes":5.78,"words":1733},"filePathRelative":"posts/Java/Ruoyi-Vue-Pro/2.后端手册/19.Redis 缓存.md","localizedDate":"2024年11月21日","excerpt":"\\n<p><a href=\\"https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-redis/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>yudao-spring-boot-starter-redis</code> (opens new window)</a>技术组件，使用 Redis 实现缓存的功能，它有 2 种使用方式：</p>\\n<ul>\\n<li>编程式缓存：基于 Spring Data Redis 框架的 RedisTemplate 操作模板</li>\\n<li>声明式缓存：基于 Spring Cache 框架的 <code>@Cacheable</code> 等等注解</li>\\n</ul>","autoDesc":true}');export{d as comp,p as data};
