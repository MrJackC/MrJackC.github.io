import{_ as i,c as t,a as l,o}from"./app-JRvFIbSa.js";const n={};function r(a,e){return o(),t("div",null,e[0]||(e[0]=[l('<h1 id="消息中心各场景消息发送逻辑" tabindex="-1"><a class="header-anchor" href="#消息中心各场景消息发送逻辑"><span>消息中心各场景消息发送逻辑</span></a></h1><h2 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介"><span>1. 简介</span></a></h2><p>消息中心在各场景下的发送逻辑是不一致的，例如</p><ul><li>发送给单人的业务消息。我们希望发送完消息后，用户立即收到消息</li><li>而像类似通知公告这类消息，面向的是所有用户，那么我们不可能一次性发给所有用户。所以我们采用登录或进入首页后，重新拉取新消息的模式</li></ul><h2 id="_2-接口设计" tabindex="-1"><a class="header-anchor" href="#_2-接口设计"><span>2. 接口设计</span></a></h2><p>NotifyService拥有以下方法:</p><ul><li>createAnnounce(content, sender) <ol><li>往Notify表中插入一条公告记录</li></ol></li><li>createRemind(target, targetType, action, sender, content) <ol><li>往Notify表中插入一条提醒记录</li></ol></li><li>createMessage(content, sender, receiver) <ol><li>往Notify表中插入一条信息记录</li><li>往UserNotify表中插入一条记录，并关联新建的Notify</li></ol></li><li>pullAnnounce(user) <ol><li>从UserNotify中获取最近的一条公告信息的创建时间: <code>lastTime</code></li><li>用<code>lastTime</code>作为过滤条件，查询Notify的公告信息</li><li>新建UserNotify并关联查询出来的公告信息</li></ol></li><li>pullRemind(user) <ol><li>查询用户的订阅表，得到用户的一系列订阅记录</li><li>通过每一条的订阅记录的<code>target</code>、<code>targetType</code>、<code>action</code>、<code>createdAt</code>去查询Notify表，获取订阅的Notify记录。（注意订阅时间必须早于提醒创建时间）</li><li>查询用户的配置文件SubscriptionConfig，如果没有则使用默认的配置DefaultSubscriptionConfig</li><li>使用订阅配置，过滤查询出来的Notify</li><li>使用过滤好的Notify作为关联新建UserNotify</li></ol></li><li>subscribe(user, target, targetType, reason) <ol><li>通过reason，查询NotifyConfig，获取对应的动作组:<code>actions</code></li><li>遍历动作组，每一个动作新建一则Subscription记录</li></ol></li><li>cancelSubscription(user, target ,targetType) <ol><li>删除<code>user</code>、<code>target</code>、<code>targetType</code>对应的一则或多则记录</li></ol></li><li>getSubscriptionConfig(userID) <ol><li>查询SubscriptionConfig表，获取用户的订阅配置</li></ol></li><li>updateSubscriptionConfig(userID) <ol><li>更新用户的SubscriptionConfig记录</li></ol></li><li>getUserNotify(userID) <ol><li>获取用户的消息列表</li></ol></li><li>read(user, notifyIDs) <ol><li>更新指定的notify，把isRead属性设置为true</li></ol></li></ul><h2 id="_3-各场景发送逻辑" tabindex="-1"><a class="header-anchor" href="#_3-各场景发送逻辑"><span>3. 各场景发送逻辑</span></a></h2><h3 id="_3-1-提醒的订阅、创建、拉取" tabindex="-1"><a class="header-anchor" href="#_3-1-提醒的订阅、创建、拉取"><span>3.1 提醒的订阅、创建、拉取</span></a></h3><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202404301224446.png" alt="image-20211103151303897" tabindex="0" loading="lazy"><figcaption>image-20211103151303897</figcaption></figure><ol><li>我们可以在产品创建之后，调用<code>NotifyService.subscribe</code>方法，</li><li>然后在产品被评论之后调用<code>NotifyService.createRemind</code>方法，</li><li>再就是用户登录系统或者其他的某一个时刻调</li><li>用<code>NotifyService.pullRemind</code>方法，<br> 最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</li></ol><h3 id="_3-2-公告的创建、拉取" tabindex="-1"><a class="header-anchor" href="#_3-2-公告的创建、拉取"><span>3.2 公告的创建、拉取</span></a></h3><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202404301224488.png" alt="image-20211103151351090" tabindex="0" loading="lazy"><figcaption>image-20211103151351090</figcaption></figure><ol><li>在管理员发送了一则公告的时候，调用<code>NotifyService.createAnnounce</code>方法，</li><li>然后在用户登录系统或者其他的某一个时刻调用<code>NotifyService.pullAnnounce</code>方法，</li><li>最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</li></ol><h3 id="_3-3-信息的创建" tabindex="-1"><a class="header-anchor" href="#_3-3-信息的创建"><span>3.3 信息的创建</span></a></h3><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202404301224515.png" alt="image-20211103151524274" tabindex="0" loading="lazy"><figcaption>image-20211103151524274</figcaption></figure><p>信息的创建，只需要直接调用<code>NotifyService.createMessage</code>方法就可以了，<br> 在下一次用户查询消息队列的时候，就会查询这条信息。</p><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章"><span>参考文章</span></a></h2><p><a href="https://www.jianshu.com/p/6bf8166b291c" target="_blank" rel="noopener noreferrer">消息系统设计与实现「下篇」</a></p>',19)]))}const s=i(n,[["render",r],["__file","message-system-process.html.vue"]]),d=JSON.parse('{"path":"/posts/Architect/messagesystem/message-system-process.html","title":"消息中心各场景消息发送逻辑","lang":"zh-CN","frontmatter":{"description":"消息中心各场景消息发送逻辑 1. 简介 消息中心在各场景下的发送逻辑是不一致的，例如 发送给单人的业务消息。我们希望发送完消息后，用户立即收到消息 而像类似通知公告这类消息，面向的是所有用户，那么我们不可能一次性发给所有用户。所以我们采用登录或进入首页后，重新拉取新消息的模式 2. 接口设计 NotifyService拥有以下方法: createAnn...","watermark":true,"head":[["meta",{"property":"og:url","content":"https://springg.us.kg/posts/Architect/messagesystem/message-system-process.html"}],["meta",{"property":"og:site_name","content":"mrjason’s Blog"}],["meta",{"property":"og:title","content":"消息中心各场景消息发送逻辑"}],["meta",{"property":"og:description","content":"消息中心各场景消息发送逻辑 1. 简介 消息中心在各场景下的发送逻辑是不一致的，例如 发送给单人的业务消息。我们希望发送完消息后，用户立即收到消息 而像类似通知公告这类消息，面向的是所有用户，那么我们不可能一次性发给所有用户。所以我们采用登录或进入首页后，重新拉取新消息的模式 2. 接口设计 NotifyService拥有以下方法: createAnn..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202404301224446.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-28T01:58:08.000Z"}],["meta",{"property":"article:author","content":"MrJason"}],["meta",{"property":"article:modified_time","content":"2024-10-28T01:58:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"消息中心各场景消息发送逻辑\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202404301224446.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202404301224488.png\\",\\"https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202404301224515.png\\"],\\"dateModified\\":\\"2024-10-28T01:58:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MrJason\\",\\"url\\":\\"https://springg.us.kg\\"}]}"]]},"headers":[{"level":2,"title":"1. 简介","slug":"_1-简介","link":"#_1-简介","children":[]},{"level":2,"title":"2. 接口设计","slug":"_2-接口设计","link":"#_2-接口设计","children":[]},{"level":2,"title":"3. 各场景发送逻辑","slug":"_3-各场景发送逻辑","link":"#_3-各场景发送逻辑","children":[{"level":3,"title":"3.1 提醒的订阅、创建、拉取","slug":"_3-1-提醒的订阅、创建、拉取","link":"#_3-1-提醒的订阅、创建、拉取","children":[]},{"level":3,"title":"3.2 公告的创建、拉取","slug":"_3-2-公告的创建、拉取","link":"#_3-2-公告的创建、拉取","children":[]},{"level":3,"title":"3.3 信息的创建","slug":"_3-3-信息的创建","link":"#_3-3-信息的创建","children":[]}]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1730080688000,"updatedTime":1730080688000,"contributors":[{"name":"MrJason","email":"845886914@qq.com","commits":1}]},"readingTime":{"minutes":2.49,"words":747},"filePathRelative":"posts/Architect/messagesystem/message-system-process.md","localizedDate":"2024年10月28日","excerpt":"\\n<h2>1. 简介</h2>\\n<p>消息中心在各场景下的发送逻辑是不一致的，例如</p>\\n<ul>\\n<li>发送给单人的业务消息。我们希望发送完消息后，用户立即收到消息</li>\\n<li>而像类似通知公告这类消息，面向的是所有用户，那么我们不可能一次性发给所有用户。所以我们采用登录或进入首页后，重新拉取新消息的模式</li>\\n</ul>\\n<h2>2. 接口设计</h2>\\n<p>NotifyService拥有以下方法:</p>\\n<ul>\\n<li>createAnnounce(content, sender)\\n<ol>\\n<li>往Notify表中插入一条公告记录</li>\\n</ol>\\n</li>\\n<li>createRemind(target, targetType, action, sender, content)\\n<ol>\\n<li>往Notify表中插入一条提醒记录</li>\\n</ol>\\n</li>\\n<li>createMessage(content, sender, receiver)\\n<ol>\\n<li>往Notify表中插入一条信息记录</li>\\n<li>往UserNotify表中插入一条记录，并关联新建的Notify</li>\\n</ol>\\n</li>\\n<li>pullAnnounce(user)\\n<ol>\\n<li>从UserNotify中获取最近的一条公告信息的创建时间: <code>lastTime</code></li>\\n<li>用<code>lastTime</code>作为过滤条件，查询Notify的公告信息</li>\\n<li>新建UserNotify并关联查询出来的公告信息</li>\\n</ol>\\n</li>\\n<li>pullRemind(user)\\n<ol>\\n<li>查询用户的订阅表，得到用户的一系列订阅记录</li>\\n<li>通过每一条的订阅记录的<code>target</code>、<code>targetType</code>、<code>action</code>、<code>createdAt</code>去查询Notify表，获取订阅的Notify记录。（注意订阅时间必须早于提醒创建时间）</li>\\n<li>查询用户的配置文件SubscriptionConfig，如果没有则使用默认的配置DefaultSubscriptionConfig</li>\\n<li>使用订阅配置，过滤查询出来的Notify</li>\\n<li>使用过滤好的Notify作为关联新建UserNotify</li>\\n</ol>\\n</li>\\n<li>subscribe(user, target, targetType, reason)\\n<ol>\\n<li>通过reason，查询NotifyConfig，获取对应的动作组:<code>actions</code></li>\\n<li>遍历动作组，每一个动作新建一则Subscription记录</li>\\n</ol>\\n</li>\\n<li>cancelSubscription(user, target ,targetType)\\n<ol>\\n<li>删除<code>user</code>、<code>target</code>、<code>targetType</code>对应的一则或多则记录</li>\\n</ol>\\n</li>\\n<li>getSubscriptionConfig(userID)\\n<ol>\\n<li>查询SubscriptionConfig表，获取用户的订阅配置</li>\\n</ol>\\n</li>\\n<li>updateSubscriptionConfig(userID)\\n<ol>\\n<li>更新用户的SubscriptionConfig记录</li>\\n</ol>\\n</li>\\n<li>getUserNotify(userID)\\n<ol>\\n<li>获取用户的消息列表</li>\\n</ol>\\n</li>\\n<li>read(user, notifyIDs)\\n<ol>\\n<li>更新指定的notify，把isRead属性设置为true</li>\\n</ol>\\n</li>\\n</ul>","autoDesc":true}');export{s as comp,d as data};
