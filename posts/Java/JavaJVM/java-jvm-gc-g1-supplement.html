<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.12" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.46" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://mrjackc.github.io/posts/Java/JavaJVM/java-jvm-gc-g1-supplement.html"><meta property="og:site_name" content="mrjason’s Blog"><meta property="og:title" content="GC - Java 垃圾回收器之G1（补充）"><meta property="og:description" content="GC - Java 垃圾回收器之G1（补充） 1. 前言 G1:满足高吞吐量的同时满足GC停顿的时间尽可能短 G1收集器是一款在server端运行的垃圾收集器，专门针对于拥有多核处理器和大内存的机器，在JDK 7u4版本发行时被正式推出，在JDK9中更被指定为官方GC收集器。它满足高吞吐量的同时满足GC停顿的时间尽可能短。 1.1. G1 优势 G1收..."><meta property="og:type" content="article"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120957681.png"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-10-21T07:03:09.000Z"><meta property="article:author" content="MrJason"><meta property="article:modified_time" content="2024-10-21T07:03:09.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"GC - Java 垃圾回收器之G1（补充）","image":["https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120957681.png","https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120957719.png","https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120957748.png","https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120957778.png","https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120957806.png"],"dateModified":"2024-10-21T07:03:09.000Z","author":[{"@type":"Person","name":"MrJason","url":"https://mrjackc.github.io"}]}</script><meta name="referrer" content="no-referrer-when-downgrade"><link rel="icon" href="/favicon.ico"><link rel="icon" href="/assets/icon/chrome-mask-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/assets/icon/chrome-mask-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/assets/icon/chrome-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/assets/icon/chrome-192.png" type="image/png" sizes="192x192"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><link rel="apple-touch-icon" href="/assets/icon/apple-icon-152.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileImage" content="/assets/icon/ms-icon-144.png"><meta name="msapplication-TileColor" content="#ffffff"><link rel="alternate" type="application/rss+xml" href="https://mrjackc.github.io/rss.xml" title="mrjason’s Blog RSS Feed"><title>GC - Java 垃圾回收器之G1（补充） | mrjason’s Blog</title><meta name="description" content="GC - Java 垃圾回收器之G1（补充） 1. 前言 G1:满足高吞吐量的同时满足GC停顿的时间尽可能短 G1收集器是一款在server端运行的垃圾收集器，专门针对于拥有多核处理器和大内存的机器，在JDK 7u4版本发行时被正式推出，在JDK9中更被指定为官方GC收集器。它满足高吞吐量的同时满足GC停顿的时间尽可能短。 1.1. G1 优势 G1收...">
    <link rel="preload" href="/assets/style-D5zIXRKB.css" as="style"><link rel="stylesheet" href="/assets/style-D5zIXRKB.css">
    <link rel="modulepreload" href="/assets/app-DQS7qcOs.js"><link rel="modulepreload" href="/assets/java-jvm-gc-g1-supplement.html-BHgAPaJu.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/logo.svg" alt><!----><span class="vp-site-name hide-in-pad">mrjason’s Blog</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="主页"><!--[--><span class="font-icon icon iconfont icon-home" style=""></span><!--]-->主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/demo/" aria-label="导航"><!--[--><span class="font-icon icon iconfont icon-discover" style=""></span><!--]-->导航<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="笔记分类"><!--[--><span class="font-icon icon iconfont icon-edit" style=""></span>笔记分类<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">代码笔记</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Computer-Basics/" aria-label="计算机基础"><!--[--><span class="font-icon icon iconfont icon-windows" style=""></span><!--]-->计算机基础<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Data-Structure/" aria-label="数据结构与算法"><!--[--><span class="font-icon icon iconfont icon-calculate" style=""></span><!--]-->数据结构与算法<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Web/" aria-label="前端笔记"><!--[--><span class="font-icon icon iconfont icon-code" style=""></span><!--]-->前端笔记<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Linux/" aria-label="Linux"><!--[--><span class="font-icon icon iconfont icon-linux" style=""></span><!--]-->Linux<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Python/" aria-label="Python"><!--[--><span class="font-icon icon iconfont icon-python" style=""></span><!--]-->Python<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Database/" aria-label="数据库"><!--[--><span class="font-icon icon iconfont icon-table" style=""></span><!--]-->数据库<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Docker/" aria-label="Docker"><!--[--><span class="font-icon icon iconfont icon-expansion" style=""></span><!--]-->Docker<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Git/" aria-label="Git"><!--[--><span class="font-icon icon iconfont icon-git" style=""></span><!--]-->Git<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Redis/" aria-label="Redis"><!--[--><span class="font-icon icon iconfont icon-lock" style=""></span><!--]-->Redis<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/MiddleWare/" aria-label="中间件"><!--[--><span class="font-icon icon iconfont icon-process" style=""></span><!--]-->中间件<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/BigData/" aria-label="大数据"><!--[--><span class="font-icon icon iconfont icon-hot" style=""></span><!--]-->大数据<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Architect/" aria-label="架构师"><!--[--><span class="font-icon icon iconfont icon-study" style=""></span><!--]-->架构师<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Daily-Thoughts/" aria-label="日常思考"><!--[--><span class="font-icon icon iconfont icon-mark" style=""></span><!--]-->日常思考<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Development-Tools/" aria-label="开发工具"><!--[--><span class="font-icon icon iconfont icon-tool" style=""></span><!--]-->开发工具<!----></a></li></ul></li><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">博客相关</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/blog/" aria-label="博客相关"><!--[--><span class="font-icon icon iconfont icon-blog" style=""></span><!--]-->博客相关<!----></a></li></ul></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><a class="route-link route-link-active auto-link" href="/posts/Java/" aria-label="Java"><!--[--><span class="font-icon icon iconfont icon-java" style=""></span><!--]-->Java<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/collect.html" aria-label="收藏"><!--[--><span class="font-icon icon iconfont icon-hk-shoucang1" style=""></span><!--]-->收藏<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/news/" aria-label="说说"><!--[--><span class="font-icon icon iconfont icon-news" style=""></span><!--]-->说说<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/visitorsbook.html" aria-label="留言板"><!--[--><span class="font-icon icon iconfont icon-mark" style=""></span><!--]-->留言板<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/friend.html" aria-label="友链"><!--[--><span class="font-icon icon iconfont icon-link" style=""></span><!--]-->友链<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="关于"><!--[--><span class="font-icon icon iconfont icon-info" style=""></span>关于<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/intro.html" aria-label="关于我"><!--[--><span class="font-icon icon iconfont icon-people" style=""></span><!--]-->关于我<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/about.html" aria-label="关于本站"><!--[--><span class="font-icon icon iconfont icon-info" style=""></span><!--]-->关于本站<!----></a></li></ul></button></div></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/MrjackC/mrjackc.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://foreverblog.cn/go.html" title="穿梭虫洞-随机访问十年之约友链博客" target="_blank" rel="noopener noreferrer" aria-label="wormhole"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" fill="currentColor" style="width:1.25rem;height:1.25rem;vertical-align:middle"><path d="M644.608 665.6c192.512-171.008 342.016-395.776 254.464-494.592-27.648-31.232-66.56-45.568-108.032-41.472-34.816 3.584-70.656 20.992-107.008 50.176-116.224-59.904-254.464-55.296-366.592 11.776-86.016 51.2-148.48 134.656-172.544 231.936-18.944 74.24-14.336 152.064 12.8 223.744-44.544 50.688-86.528 154.624-34.816 212.992 21.504 24.576 52.736 35.328 90.112 35.328 114.176-0.512 286.72-100.864 431.616-229.888z m155.648-452.608c14.848-1.536 26.624 2.56 36.352 13.824 9.728 10.752 7.168 39.936-10.752 80.896-18.944-28.672-41.984-55.296-68.096-77.824 17.92-10.752 32.256-15.872 42.496-16.896z m-598.528 517.12c18.944 27.136 40.96 51.712 66.048 73.216-43.008 12.8-72.192 11.776-81.92 1.024-8.704-10.752 0.512-45.056 15.872-74.24z m685.568-246.784c-51.2 75.264-122.368 154.112-200.704 224.256-81.408 72.192-171.008 134.656-254.464 176.64 26.112 5.632 52.224 8.704 78.848 8.704 68.096 0 135.168-18.944 194.048-53.76 124.416-73.216 195.072-211.968 182.272-355.84z m0 0" p-id="4157"></path></svg></a></div><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://www.travellings.cn/go.html" title="开往" target="_blank" rel="noopener noreferrer" aria-label="travelling"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" fill="currentColor" style="width:1.25rem;height:1.25rem;vertical-align:middle"><path d="M658.836 519.32c-22.121 0-40.145 18.431-40.145 40.957 0 22.528 18.023 40.962 40.145 40.962 22.117 0 40.141-18.434 40.141-40.962 0-22.526-18.024-40.957-40.141-40.957zM364.742 519.32c-22.121 0-40.141 18.431-40.141 40.957 0.41 22.528 18.02 40.962 40.141 40.962 22.117 0 40.141-18.434 40.141-40.962 0-22.526-18.024-40.957-40.141-40.957z" p-id="8700"></path><path d="M512 0C229.23 0 0 229.23 0 512s229.23 512 512 512 512-229.23 512-512S794.77 0 512 0z m133.727 804.81c0 7.375-6.145 13.52-13.516 13.52H391.773c-7.371 0-13.515-6.145-13.515-13.52v-13.516c0-7.371 6.144-13.517 13.515-13.517h240.438c7.371 0 13.516 6.146 13.516 13.517v13.516z m120.832 37.273c-12.289 6.965-27.441 2.867-34.406-9.418l-54.887-96.668c-4.504 0.82-9.422 1.23-13.926 1.23H361.054c-4.914 0-9.421-0.41-13.925-1.23l-54.887 96.668c-6.965 12.285-22.527 16.383-34.406 9.418-12.289-6.961-16.383-22.938-9.422-35.223l51.199-90.113c-27.031-19.66-43.418-52.43-40.957-88.883l19.25-293.273c3.277-49.152 34.406-88.066 87.246-88.066h80.281c0-37.684 29.899-67.993 66.762-67.993 36.868 0 66.766 30.309 66.766 67.993h93.391c53.246 0 70.449 38.914 73.727 88.066l19.25 293.273c2.461 36.453-13.926 69.223-40.957 88.883l51.199 90.113c6.964 12.696 2.867 28.262-9.012 35.223z" p-id="8701"></path><path d="M672.352 314.931H351.633c-14.747 0-26.622 12.285-26.622 27.441v108.953c0 15.157 11.875 27.446 26.622 27.446h320.719c14.746 0 26.625-12.289 26.625-27.446V342.372c0-15.156-11.879-27.441-26.625-27.441z" p-id="8702"></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon" name="outlook"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="vp-outlook-dropdown"><!----></div></button></div><!--[--><div id="docsearch-container" style="display:none;"></div><div><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"><svg width="15" height="15" class="DocSearch-Control-Key-Icon"><path d="M4.505 4.496h2M5.505 5.496v5M8.216 4.496l.055 5.993M10 7.5c.333.333.5.667.5 1v2M12.326 4.5v5.996M8.384 4.496c1.674 0 2.116 0 2.116 1.5s-.442 1.5-2.116 1.5M3.205 9.303c-.09.448-.277 1.21-1.241 1.203C1 10.5.5 9.513.5 8V7c0-1.57.5-2.5 1.464-2.494.964.006 1.134.598 1.24 1.342M12.553 10.5h1.953" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="square"></path></svg></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Java基础</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Java集合</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">JavaWeb</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Java IO</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">Java JVM</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/jvm-overview.html" aria-label="JVM相关知识体系详解"><!---->JVM相关知识体系详解<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-class.html" aria-label="JVM 基础 - 类字节码详解"><!---->JVM 基础 - 类字节码详解<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-class-enhancer.html" aria-label="JVM 基础 - 字节码的增强技术"><!---->JVM 基础 - 字节码的增强技术<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-classload.html" aria-label="JVM 基础 - Java 类加载机制"><!---->JVM 基础 - Java 类加载机制<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-struct.html" aria-label="JVM 基础 - JVM 内存结构"><!---->JVM 基础 - JVM 内存结构<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-heap-s.html" aria-label="JVM 基础 - Java内存结构(精简版)"><!---->JVM 基础 - Java内存结构(精简版)<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-x-introduce.html" aria-label="JVM 基础 - Java 内存模型引入"><!---->JVM 基础 - Java 内存模型引入<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-jmm.html" aria-label="JVM 基础 - Java 内存模型详解"><!---->JVM 基础 - Java 内存模型详解<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-gc.html" aria-label="GC - Java 垃圾回收基础知识"><!---->GC - Java 垃圾回收基础知识<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-gc-g1.html" aria-label="GC - Java 垃圾回收器之G1详解"><!---->GC - Java 垃圾回收器之G1详解<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link vp-sidebar-page active" href="/posts/Java/JavaJVM/java-jvm-gc-g1-supplement.html" aria-label="GC - Java 垃圾回收器之G1（补充）"><!---->GC - Java 垃圾回收器之G1（补充）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-cms-gc.html" aria-label="GC - Java 垃圾回收器之CMS GC问题分析与解决"><!---->GC - Java 垃圾回收器之CMS GC问题分析与解决<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-param.html" aria-label="调试排错 - JVM 调优参数"><!---->调试排错 - JVM 调优参数<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-oom.html" aria-label="调试排错 - Java 内存分析之堆内存和MetaSpace内存"><!---->调试排错 - Java 内存分析之堆内存和MetaSpace内存<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-oom-offheap.html" aria-label="调试排错 - Java 内存分析之堆外内存"><!---->调试排错 - Java 内存分析之堆外内存<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-thread-dump.html" aria-label="调试排错 - Java 线程分析之线程Dump分析"><!---->调试排错 - Java 线程分析之线程Dump分析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-oom-tool.html" aria-label="调试排错 - Java 问题排查之JVM可视化工具"><!---->调试排错 - Java 问题排查之JVM可视化工具<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-agent-arthas.html" aria-label="调试排错 - Java 问题排查之应用在线调试Arthas"><!---->调试排错 - Java 问题排查之应用在线调试Arthas<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-agent-arthas-problem.html" aria-label="调试排错 - Arthas 遇到的问题"><!---->调试排错 - Arthas 遇到的问题<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-debug-idea.html" aria-label="调试排错 - Java 问题排查之使用IDEA本地调试和远程调试"><!---->调试排错 - Java 问题排查之使用IDEA本地调试和远程调试<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-agent-usage.html" aria-label="调试排错 - Java动态调试技术原理"><!---->调试排错 - Java动态调试技术原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-thread-x-lock-ReentrantLock.html" aria-label="JUC锁: ReentrantLock详解"><!---->JUC锁: ReentrantLock详解<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-gc-help.html" aria-label="GC中对象自救"><!---->GC中对象自救<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-gc-log.html" aria-label="gc日志分析"><!---->gc日志分析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-optimization-size.html" aria-label="Java堆设置多大合适"><!---->Java堆设置多大合适<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-gc-adapter.html" aria-label="Java如何选择合适的垃圾回收器"><!---->Java如何选择合适的垃圾回收器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-tools-overview.html" aria-label="JDK监控和故障处理工具汇总"><!---->JDK监控和故障处理工具汇总<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-optimization-jstack.html" aria-label="jstack等命令的实现原理"><!---->jstack等命令的实现原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-gc-dispatch.html" aria-label="JVM 内存分配与回收"><!---->JVM 内存分配与回收<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-tools-visualvm.html" aria-label="mac版idea配置visualvm"><!---->mac版idea配置visualvm<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-tools-mat-use.html" aria-label="MAT使用"><!---->MAT使用<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-tools-mat.html" aria-label="MAT安装"><!---->MAT安装<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-tools-mat-shallow.html" aria-label="Shallow heap和Retained heap"><!---->Shallow heap和Retained heap<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-classload-tomcat.html" aria-label="tomcat类加载器"><!---->tomcat类加载器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-gc-overview.html" aria-label="垃圾收集器"><!---->垃圾收集器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-gc-orth.html" aria-label="垃圾收集器垃圾收集算法"><!---->垃圾收集器垃圾收集算法<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-optimization.html" aria-label="如何合理的规划 JVM 性能调优"><!---->如何合理的规划 JVM 性能调优<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-gc-object-die.html" aria-label="对象已经死亡？"><!---->对象已经死亡？<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-classload1.html" aria-label="类加载器"><!---->类加载器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-classload-interview.html" aria-label="类加载器（常见面试）"><!---->类加载器（常见面试）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/jvm.html" aria-label="类加载过程"><!---->类加载过程<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-classload-simplify.html" aria-label="类加载过程(精简版)"><!---->类加载过程(精简版)<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-gc-fullgc.html" aria-label="线上如何排查FullGC(系统 CPU 突然飙升且 GC 频繁，你该如何排查)"><!---->线上如何排查FullGC(系统 CPU 突然飙升且 GC 频繁，你该如何排查)<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-tools-mat-peoject.html" aria-label="记一次MAT分析线上项目过程"><!---->记一次MAT分析线上项目过程<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-debug-tools-linux.html" aria-label="调试排错 - Java 问题排查之Linux命令"><!---->调试排错 - Java 问题排查之Linux命令<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/Java/JavaJVM/java-jvm-debug-tools-list.html" aria-label="调试排错 - Java 问题排查之工具单"><!---->调试排错 - Java 问题排查之工具单<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Java8特性</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Java多线程</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Java框架</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Java第三方依赖</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Java编译</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->GC - Java 垃圾回收器之G1（补充）</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://mrjackc.github.io" target="_blank" rel="noopener noreferrer">MrJason</a></span><span property="author" content="MrJason"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-10-21T07:03:09.000Z"></span><span class="page-pageview-info" aria-label="访问量🔢" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon eye-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="eye icon" name="eye"><path d="M992 512.096c0-5.76-.992-10.592-1.28-11.136-.192-2.88-1.152-8.064-2.08-10.816-.256-.672-.544-1.376-.832-2.08-.48-1.568-1.024-3.104-1.6-4.32C897.664 290.112 707.104 160 512 160c-195.072 0-385.632 130.016-473.76 322.592-1.056 2.112-1.792 4.096-2.272 5.856a55.512 55.512 0 00-.64 1.6c-1.76 5.088-1.792 8.64-1.632 7.744-.832 3.744-1.568 11.168-1.568 11.168-.224 2.272-.224 4.032.032 6.304 0 0 .736 6.464 1.088 7.808.128 1.824.576 4.512 1.12 6.976h-.032c.448 2.08 1.12 4.096 1.984 6.08.48 1.536.992 2.976 1.472 4.032C126.432 733.856 316.992 864 512 864c195.136 0 385.696-130.048 473.216-321.696 1.376-2.496 2.24-4.832 2.848-6.912.256-.608.48-1.184.672-1.728 1.536-4.48 1.856-8.32 1.728-8.32l-.032.032c.608-3.104 1.568-7.744 1.568-13.28zM512 672c-88.224 0-160-71.776-160-160s71.776-160 160-160 160 71.776 160 160-71.776 160-160 160z"></path></svg><span id="ArtalkPV" class="vp-pageview waline-pageview-count" data-path="/posts/Java/JavaJVM/java-jvm-gc-g1-supplement.html" data-page-key="/posts/Java/JavaJVM/java-jvm-gc-g1-supplement.html">...</span></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 21 分钟</span><meta property="timeRequired" content="PT21M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item color8 clickable" role="navigation">Java</span><span class="page-category-item color7 clickable" role="navigation">JVM</span><!--]--><meta property="articleSection" content="Java,JVM"></span><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_1-前言">1. 前言</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-1-g1-优势">1.1. G1 优势</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-2-与cms不同点">1.2 与CMS不同点</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_2-概览">2. 概览</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-1-分区region-各区比例">2.1 分区region 各区比例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-2-为什么叫g1-全局并发标记-优先回收">2.2 为什么叫G1（全局并发标记-&gt;优先回收）</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-3-暂停预测模型">2.3 暂停预测模型</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_3-g1中的region">3. G1中的Region</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_4-g1中的gc收集">4. G1中的GC收集</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_5-ygc">5.YGC</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-1-ygc开始">5.1 YGC开始</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-2-ygc结束">5.2 YGC结束</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-3-ygc是否需要扫描整个老年代-rset">5.3 YGC是否需要扫描整个老年代？Rset</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_6-mixgc">6. MIXGC</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-1-全局并发标记">6.1 全局并发标记</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-2-全局并发标记总结">6.2 全局并发标记总结</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-3-stab-维持并发gc的正确性">6.3 STAB（维持并发GC的正确性）</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-4-stab具体细节">6.4 STAB具体细节</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_7-g1命令行选项与最佳实践">7. G1命令行选项与最佳实践</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_7-1-命令行选项">7.1 命令行选项</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_7-2-最佳实践">7.2 最佳实践</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_7-3-完整的g1-gc开关列表">7.3 完整的G1 GC开关列表</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_8-总结">8. 总结</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#参考文章">参考文章</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content"><h1 id="gc-java-垃圾回收器之g1-补充" tabindex="-1"><a class="header-anchor" href="#gc-java-垃圾回收器之g1-补充"><span>GC - Java 垃圾回收器之G1（补充）</span></a></h1><h2 id="_1-前言" tabindex="-1"><a class="header-anchor" href="#_1-前言"><span>1. 前言</span></a></h2><blockquote><p>G1:满足高吞吐量的同时满足GC停顿的时间尽可能短</p></blockquote><p>G1收集器是一款在server端运行的垃圾收集器，专门针对于拥有多核处理器和大内存的机器，在JDK 7u4版本发行时被正式推出，在JDK9中更被指定为官方GC收集器。<strong>它满足高吞吐量的同时满足GC停顿的时间尽可能短</strong>。</p><h3 id="_1-1-g1-优势" tabindex="-1"><a class="header-anchor" href="#_1-1-g1-优势"><span>1.1. G1 优势</span></a></h3><p>G1收集器专门针对以下应用场景设计</p><ul><li>可以像CMS收集器一样可以和应用并发运行</li><li>压缩空闲的内存碎片，却不需要冗长的GC停顿</li><li>对GC停顿可以做更好的预测</li><li>不想牺牲大量的吞吐量性能</li><li>不需要更大的Java Heap</li></ul><blockquote><p>Can operate concurrently with applications threads like the CMS collector.<br> Compact free space without lengthy GC induced pause times.<br> Need more predictable GC pause durations.<br> Do not want to sacrifice a lot of throughput performance.<br> Do not require a much larger Java heap.</p></blockquote><h3 id="_1-2-与cms不同点" tabindex="-1"><a class="header-anchor" href="#_1-2-与cms不同点"><span>1.2 与CMS不同点</span></a></h3><p>G1从长期计划来看是以取代CMS为目标。与CMS相比有几个不同点使得G1成为GC的更好解决方案。</p><ul><li>第一点：G1会压缩空闲内存使之足够紧凑，做法<strong>是用regions代替细粒度的空闲列表进行分配</strong>，减少内存碎片的产生。</li><li>第二点：G1的STW更可控，G1在停顿时间上添加了<strong>预测机制</strong>，用户可以指定期望停顿时间。</li></ul><blockquote><p>G1 is planned as the long term replacement for the Concurrent Mark-Sweep Collector (CMS). Comparing G1 with CMS, there are differences that make G1 a better solution. One difference is that G1 is a compacting collector. G1 compacts sufficiently to completely avoid the use of fine-grained free lists for allocation, and instead relies on regions. This considerably simplifies parts of the collector, and mostly eliminates potential fragmentation issues. Also, G1 offers more predictable garbage collection pauses than the CMS collector, and allows users to specify desired pause targets.</p></blockquote><h2 id="_2-概览" tabindex="-1"><a class="header-anchor" href="#_2-概览"><span>2. 概览</span></a></h2><p>在传统的GC收集器(serial,parallel,CMS)无一不例外都把heap分成固定大小连续的三个空间：young generation, old generation, and permanent generation</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120957681.png" alt="image-20221209111945943" tabindex="0" loading="lazy"><figcaption>image-20221209111945943</figcaption></figure><p>但G1却独辟蹊径，采用了一种全新的内存布局</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120957719.png" alt="image-20221209112005861" tabindex="0" loading="lazy"><figcaption>image-20221209112005861</figcaption></figure><p>在G1中堆被分成一块块大小相等的heap region，一般有2000多块，这些region在逻辑上是连续的。每块region都会被打唯一的分代标志(eden,survivor,old)。在逻辑上，eden regions构成Eden空间，survivor regions构成Survivor空间，old regions构成了old 空间。</p><h3 id="_2-1-分区region-各区比例" tabindex="-1"><a class="header-anchor" href="#_2-1-分区region-各区比例"><span>2.1 分区region 各区比例</span></a></h3><p>通过命令行参数</p><ul><li><code>-XX:NewRatio=n</code>来配置新生代与老年代的比例，默认为2，即比例为2:1；</li><li><code>XX:SurvivorRatio=n</code>则可以配置Eden与Survivor的比例，默认为8。</li></ul><h3 id="_2-2-为什么叫g1-全局并发标记-优先回收" tabindex="-1"><a class="header-anchor" href="#_2-2-为什么叫g1-全局并发标记-优先回收"><span>2.2 为什么叫G1（全局并发标记-&gt;优先回收）</span></a></h3><blockquote><p>全局并发标记-&gt;可回收对象多-&gt;优先回收</p></blockquote><p>GC时G1的运行方式与CMS方式类似，会有一个全局并发标记(concurrent global marking phase)的过程，去确定堆里对象的的存活情况。并发标记完成之后，G1知道哪些regions空闲空间多(可回收对象多),优先回收这些空的regions，释放出大量的空闲空间。这是为什么这种垃圾回收方式叫G1的原因(Garbage-First)。</p><h3 id="_2-3-暂停预测模型" tabindex="-1"><a class="header-anchor" href="#_2-3-暂停预测模型"><span>2.3 暂停预测模型</span></a></h3><p>G1将其收集和压缩活动集中在堆中可能充满可回收对象(即垃圾)的区域，使用暂停预测模型来满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择要收集的区域数量。</p><p>需要注意的是，G1不是实时收集器。它能够以较高的概率满足设定的暂停时间目标，但不是绝对确定的。根据以前收集的数据，G1估算出在用户指定的目标时间内可以收集多少个区域。因此，收集器对于收集区域的成本有一个相当准确的模型，它使用这个模型来确定在暂停时间目标内收集哪些区域和收集多少区域。</p><blockquote><p>It is important to note that G1 is not a real-time collector. It meets the set pause time target with high probability but not absolute certainty. Based on data from previous collections, G1 does an estimate of how many regions can be collected within the user specified target time. Thus, the collector has a reasonably accurate model of the cost of collecting the regions, and it uses this model to determine which and how many regions to collect while staying within the pause time target.</p></blockquote><h2 id="_3-g1中的region" tabindex="-1"><a class="header-anchor" href="#_3-g1中的region"><span>3. G1中的Region</span></a></h2><p>G1中每个Region大小是固定相等的，Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围从1M到32M，且是2的指数。如果不设定，那么G1会根据Heap大小自动决定。</p><p>决定逻辑:</p><p><code>size =（堆最小值+堆最大值）/ TARGET_REGION_NUMBER(2048)</code> ，然后size取最靠近2的幂次数值， 并将size控制在[1M,32M]之间。具体代码如下</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// share/vm/gc_implementation/g1/heapRegion.cpp</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Minimum region size; we won&#39;t go lower than that.</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// We might want to decrease this in the future, to deal with small</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// heaps a bit more efficiently.</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> MIN_REGION_SIZE</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  (      1024 * 1024 )</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Maximum region size; we don&#39;t go higher than that. There&#39;s a good</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// reason for having an upper bound. We don&#39;t want regions to get too</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// large, otherwise cleanup&#39;s effectiveness would decrease as there</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// will be fewer opportunities to find totally empty regions after</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// marking.</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> MAX_REGION_SIZE</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  ( 32 * 1024 * 1024 )</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// The automatic region size calculation will try to have around this</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// many regions in the heap (based on the min heap size).</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">#define</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> TARGET_REGION_NUMBER</span><span style="color:#D19A66;--shiki-dark:#D19A66;">          2048</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">void</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> HeapRegion</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">::</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">setup_heap_region_size</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">size_t</span><span style="color:#E06C75;font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> initial_heap_size</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#C678DD;--shiki-dark:#C678DD;">size_t</span><span style="color:#E06C75;font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> max_heap_size</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  uintx region_size </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> G1HeapRegionSize;</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">FLAG_IS_DEFAULT</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(G1HeapRegionSize)) {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    size_t</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> average_heap_size </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (initial_heap_size </span><span style="color:#C678DD;--shiki-dark:#C678DD;">+</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> max_heap_size) </span><span style="color:#C678DD;--shiki-dark:#C678DD;">/</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    region_size </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> MAX2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(average_heap_size </span><span style="color:#C678DD;--shiki-dark:#C678DD;">/</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> TARGET_REGION_NUMBER,</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                       (uintx) MIN_REGION_SIZE);</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> region_size_log </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> log2_long</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">((jlong) region_size);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Recalculate the region size to make sure it&#39;s a power of</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 2. This means that region_size is the largest power of 2 that&#39;s</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // &lt;= what we&#39;ve calculated so far.</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  region_size </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ((uintx)</span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> region_size_log);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Now make sure that we don&#39;t go over or under our limits.</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (region_size </span><span style="color:#C678DD;--shiki-dark:#C678DD;">&lt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> MIN_REGION_SIZE) {</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    region_size </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> MIN_REGION_SIZE;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  } </span><span style="color:#C678DD;--shiki-dark:#C678DD;">else</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (region_size </span><span style="color:#C678DD;--shiki-dark:#C678DD;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> MAX_REGION_SIZE) {</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    region_size </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> MAX_REGION_SIZE;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-g1中的gc收集" tabindex="-1"><a class="header-anchor" href="#_4-g1中的gc收集"><span>4. G1中的GC收集</span></a></h2><p><strong>G1保留了YGC并加上了一种全新的MIXGC用于收集老年代。G1中没有Full GC，G1中的Full GC是采用serial old Full GC。</strong></p><blockquote><p>Q:理解不了“G1中没有Full GC，G1中的Full GC是采用serial old Full GC。“这句话，不是说没有Full GC吗</p><p>A1: G1中实际是有full gc的只是非常慢，所以g1的优化目标是尽量避免full gc，因此才有如上说法</p><p>A2:如果mixed GC实在无法跟上程序分配内存的速度，导致old gen填满无法继续进行mixed GC，就会切换到&quot;G1之外的serial old GC&quot;来收集整个GC heap（注意，包括young、old、perm）。这才是真正的full GC。Full GC之所以叫full就是要收集整个堆，只选择old gen的部分region算不上full GC。进入这种状态的G1就跟-XX:+UseSerialGC的full GC一样</p></blockquote><h2 id="_5-ygc" tabindex="-1"><a class="header-anchor" href="#_5-ygc"><span>5.YGC</span></a></h2><p>当Eden空间被占满之后，就会触发YGC。在G1中YGC依然采用复制存活对象到survivor空间的方式，当对象的存活年龄满足晋升条件时，把对象提升到old generation regions(老年代)。</p><p>G1控制YGC开销的手段是动态改变young region的个数，YGC的过程中依然会STW(stop the world 应用停顿)，并采用多线程并发复制对象，减少GC停顿时间。</p><h3 id="_5-1-ygc开始" tabindex="-1"><a class="header-anchor" href="#_5-1-ygc开始"><span>5.1 YGC开始</span></a></h3><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120957748.png" alt="image-20221209113334611" tabindex="0" loading="lazy"><figcaption>image-20221209113334611</figcaption></figure><h3 id="_5-2-ygc结束" tabindex="-1"><a class="header-anchor" href="#_5-2-ygc结束"><span>5.2 YGC结束</span></a></h3><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120957778.png" alt="image-20221209113401283" tabindex="0" loading="lazy"><figcaption>image-20221209113401283</figcaption></figure><p>我们从图中看到Eden区中存活对象被复制到新的Survior区。</p><h3 id="_5-3-ygc是否需要扫描整个老年代-rset" tabindex="-1"><a class="header-anchor" href="#_5-3-ygc是否需要扫描整个老年代-rset"><span>5.3 YGC是否需要扫描整个老年代？Rset</span></a></h3><p>我们知道判断对象是否存活需要从GC ROOTS结点出发，从GC ROOTS结点可达的对象就是存活的。在YGC时，老年代中的对象是不回收的，也就意味着GC ROOTS里面应包含了老年代中的对象。<strong>但扫描整个老年代会很耗费时间，势必影响整个GC的性能！</strong>。所以在CMS中使用了Card Table的结构，里面记录了老年代对象到新生代引用。**Card Table的结构是一个连续的byte[]数组，扫描Card Table的时间比扫描整个老年代的代价要小很多！G1也参照了这个思路，不过采用了一种新的数据结构 Remembered Set 简称Rset。**RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。而Card Table则是一种points-out（我引用了谁的对象）的结构，每个Card 覆盖一定范围的Heap（一般为512Bytes）。G1的RSet是在Card Table的基础上实现的：每个Region会记录下别的Region有指向自己的指针，并标记这些指针分别在哪些Card的范围内。 这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。<strong>每个Region都有一个对应的Rset</strong>。</p><figure><img src="https://cdn.jsdelivr.net/gh/MrJackC/PicGoImages/other/202403120957806.png" alt="image-20221209140929589" tabindex="0" loading="lazy"><figcaption>image-20221209140929589</figcaption></figure><p>RSet究竟是怎么辅助GC的呢？在做YGC的时候，只需要选定young generation region的RSet作为根集，这些RSet记录了<code>old-&gt;young</code>的跨代引用，避免了扫描整个old generation。 而mixed gc的时候，old generation中记录了<code>old-&gt;old</code>的RSet，<code>young-&gt;old</code>的引用由扫描全部young generation region得到，这样也不用扫描全部old generation region。所以RSet的引入大大减少了GC的工作量。</p><p><strong>所以G1中YGC不需要扫描整个老年代，只需要扫描Rset就可以知道老年代引用了哪些新生代中的对象。</strong></p><h2 id="_6-mixgc" tabindex="-1"><a class="header-anchor" href="#_6-mixgc"><span>6. MIXGC</span></a></h2><p>G1中的MIXGC选定所有新生代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region，在用户指定的开销目标范围内尽可能选择收益高的老年代Region进行回收。所以MIXGC回收的内存区域是新生代+老年代。</p><p>在介绍MIXGC之前我们需要先了解global concurrent marking，全局并发标记。因为老年代回收要依赖该过程。</p><h3 id="_6-1-全局并发标记" tabindex="-1"><a class="header-anchor" href="#_6-1-全局并发标记"><span>6.1 全局并发标记</span></a></h3><p>全局并发标记过程分为五个阶段</p><p>(1) Initial Mark初始标记 STW</p><p>Initial Mark初始标记是一个STW事件，其完成工作是标记GC ROOTS 直接可达的对象。并将它们的字段压入扫描栈（marking stack）中等到后续扫描。G1使用外部的bitmap来记录mark信息，而不使用对象头的mark word里的mark bit。因为 STW，所以通常YGC的时候借用YGC的STW顺便启动Initial Mark，也就是启动全局并发标记，全局并发标记与YGC在逻辑上独立。</p><blockquote><p>(1) Initial Mark<br> *(Stop the World Event)*This is a stop the world event. With G1, it is piggybacked on a normal young GC. Mark survivor regions (root regions) which may have references to objects in old generation.</p></blockquote><p>(2)Root Region Scanning 根区域扫描</p><p>根区域扫描是从Survior区的对象出发，标记被引用到老年代中的对象，并把它们的字段在压入扫描栈（marking stack）中等到后续扫描。与Initial Mark不一样的是，Root Region Scanning不需要STW与应用程序是并发运行。Root Region Scanning必须在YGC开始前完成。</p><blockquote><p>(2) Root Region Scanning<br> Scan survivor regions for references into the old generation. This happens while the application continues to run. The phase must be completed before a young GC can occur.</p></blockquote><p>(3)Concurrent Marking 并发标记</p><p>不需要STW。不断从扫描栈取出引用递归扫描整个堆里的对象。每扫描到一个对象就会对其标记，并将其字段压入扫描栈。重复扫描过程直到扫描栈清空。过程中还会扫描SATB write barrier所记录下的引用。Concurrent Marking 可以被YGC中断</p><blockquote><p>(3) Concurrent Marking<br> Find live objects over the entire heap. This happens while the application is running. This phase can be interrupted by young generation garbage collections.</p></blockquote><p>(4)Remark 最终标记 STW</p><p>STW操作。在完成并发标记后，每个Java线程还会有一些剩下的SATB write barrier记录的引用尚未处理。这个阶段就负责把剩下的引用处理完。同时这个阶段也进行弱引用处理（reference processing）。注意这个暂停与CMS的remark有一个本质上的区别，那就是这个暂停只需要扫描SATB buffer，而CMS的remark需要重新扫描mod-union table里的dirty card外加整个根集合，而此时整个young gen（不管对象死活）都会被当作根集合的一部分，因而CMS remark有可能会非常慢。</p><blockquote><p>(4) Remark<br> Completes the marking of live object in the heap. Uses an algorithm called snapshot-at-the-beginning (SATB) which is much faster than what was used in the CMS collector.</p></blockquote><p>(5)Cleanup 清除 STW AND <em>Concurrent</em></p><p>STW操作，清点出有存活对象的Region和没有存活对象的Region(Empty Region)</p><p>STW操作，更新Rset</p><p>Concurrent操作，把Empty Region收集起来到可分配Region队列。</p><blockquote><p>(5) Cleanup<br> Performs accounting on live objects and completely free regions. (Stop the world)<br> Scrubs the Remembered Sets. (Stop the world)<br> Reset the empty regions and return them to the free list. (Concurrent)</p></blockquote><h3 id="_6-2-全局并发标记总结" tabindex="-1"><a class="header-anchor" href="#_6-2-全局并发标记总结"><span>6.2 全局并发标记总结</span></a></h3><p><strong>经过global concurrent marking，collector就知道哪些Region有存活的对象。并将那些完全可回收的Region(没有存活对象)收集起来加入到可分配Region队列，实现对该部分内存的回收。对于有存活对象的Region，G1会根据统计模型找处收益最高、开销不超过用户指定的上限的若干Region进行对象回收。这些选中被回收的Region组成的集合就叫做collection set 简称Cset！</strong></p><p><strong>在MIXGC中的Cset是选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。</strong></p><p><strong>在YGC中的Cset是选定所有young gen里的region。通过控制young gen的region个数来控制young GC的开销。</strong></p><p><strong>YGC与MIXGC都是采用多线程复制清除，整个过程会STW。 G1的低延迟原理在于其回收的区域变得精确并且范围变小了。</strong></p><h3 id="_6-3-stab-维持并发gc的正确性" tabindex="-1"><a class="header-anchor" href="#_6-3-stab-维持并发gc的正确性"><span>6.3 STAB（维持并发GC的正确性）</span></a></h3><p>上面global concurrent marking提到了STAB算法，那这个STAB到底为何物？STAB全称为snapshot-at-the-beginning，其目的是了维持并发GC的正确性。<strong>GC的正确性是保证存活的对象不被回收，换句话来说就是保证回收的都是垃圾</strong>。如果标记过程是STW的话，那GC的正确性是一定能保证的。但如果一边标记，一边应用在变更堆里面对象的引用，那么标记的正确性就不一定能保证了。</p><p><strong>为了解决这个问题，STAB的做法在GC开始时对内存进行一个对象图的逻辑快照(snapshot)，通过GC Roots tracing 参照并发标记的过程，只要被快照到对象是活的，那在整个GC的过程中对象就被认定的是活的，即使该对象的引用稍后被修改或者删除。同时新分配的对象也会被认为是活的，除此之外其它不可达的对象就被认为是死掉了。这样STAB就保证了真正存活的对象不会被GC误回收，但同时也造成了某些可以被回收的对象逃过了GC，导致了内存里面存在浮动的垃圾(float garbage)。</strong></p><h3 id="_6-4-stab具体细节" tabindex="-1"><a class="header-anchor" href="#_6-4-stab具体细节"><span>6.4 STAB具体细节</span></a></h3><p>每个Region中都有那么几个指针</p><p><code>|&lt;-- (1) --&gt;|&lt;-- (2) --&gt;|&lt;-- (3) --&gt;|&lt;-- (4) --&gt;|</code><br> bottom prevTAMS nextTAMS top end</p><p>其中top是该region的当前分配指针，[bottom, top)是当前该region已用（used）的部分，[top, end)是尚未使用的可分配空间（unused）。</p><p>(1): [bottom, prevTAMS): 这部分里的对象存活信息可以通过prevBitmap来得知</p><p>(2): [prevTAMS, nextTAMS): 这部分里的对象在第n-1轮concurrent marking是隐式存活的</p><p>(3): [nextTAMS, top): 这部分里的对象在第n轮concurrent marking是隐式存活的</p><p>为什么会用prevTAMS和nextTAMS两个指针？</p><p>因为G1的并发标记的过程用了两个bitmap：</p><p>一个prevBitmap记录第n-1轮concurrent mark所得的对象存活状态。由于第n－1轮concurrent marking已经完成，这个bitmap的信息可以直接使用。</p><p>一个nextBitmap记录第n轮concurrent mark的结果。这个bitmap是当前将要或正在进行的concurrent mark的结果，尚未完成，所以还不能使用。</p><p>所以Region会同时存在prevTAMS和nextTAMS两个指针，这两个指针是在 Initial Mark阶段就会设置好。</p><p>所以我们很容易知道哪些对象在一次GC开始之后新分配的：在TAMS以上的对象就是新分配的，因而被视为隐式marked，标记为存活。</p><p>切换到另外一个场景：如果在标记的过程中mark了某个对象但对象中某些引用这字段还没有被mark到,此时应用并发修改引用字段的值，那collecotr就拿不到完整的快照了，这不符合STAB的设想。</p><p>为了解决这个问题就有了SATB write barrier。G1 GC具体使用的是Yuasa式的SATB write barrier的变种。它的相关论文是：</p><ul><li><a href="https://link.zhihu.com/?target=http%3A//dl.acm.org/citation.cfm%3Fid%3D82237" target="_blank" rel="noopener noreferrer">Real-time garbage collection on general-purpose</a></li></ul><p>Write barrier是对“对引用类型字段赋值”这个动作的环切，也就是说赋值的前后都在barrier覆盖的范畴内。在赋值前的部分的write barrier叫做pre-write barrier，在赋值后的则叫做post-write barrier。</p><p>在HotSpot VM里，在引入G1 GC之前，其它GC都只用了post-write barrier，所以它在源码里没有特别的前后缀；而G1 GC特有的pre-write barrier则在源码里有_pre的后缀，可以留意一下。</p><div class="language-cpp" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">void</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> oop_field_store</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">oop</span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#E06C75;font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> field</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">oop</span><span style="color:#E06C75;font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">  pre_write_barrier</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(field);</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">field </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> value;</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // the actual store</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">  post_write_barrier</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(field, value);</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><h4 id="_6-4-1-pre-post-write-barrier与satb的关系" tabindex="-1"><a class="header-anchor" href="#_6-4-1-pre-post-write-barrier与satb的关系"><span>6.4.1 Pre/Post-write barrier与SATB的关系</span></a></h4><p>前面提到SATB要维持“在GC开始时活的对象”的状态这个逻辑snapshot。除了从root出发把整个对象图mark下来之外，其实只需要用pre-write barrier把每次引用关系变化时旧的引用值记下来就好了。这样，等concurrent marker到达某个对象时，这个对象的所有引用类型字段的变化全都有记录在案，就不会漏掉任何在snapshot里活的对象。当然，很可能有对象在snapshot中是活的，但随着并发GC的进行它可能本来已经死了，但SATB还是会让它活过这次GC。</p><p>所以在G1 GC里，整个write barrier+oop_field_store是这样的：</p><div class="language-cpp" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">void</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> oop_field_store</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">oop</span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#E06C75;font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> field</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">oop</span><span style="color:#E06C75;font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> new_value</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">  pre_write_barrier</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(field);</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">             // pre-write barrier: for maintaining SATB invariant</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">field </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> new_value;</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                   // the actual store</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">  post_write_barrier</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(field, new_value);</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // post-write barrier: for tracking cross-region reference</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>按照Yuasa式SATB barrier的设计，pre-write barrier里面的抽象逻辑应当如下：</p><div class="language-cpp" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">void</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> pre_write_barrier</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">oop</span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#E06C75;font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> field</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ($gc_phase </span><span style="color:#C678DD;--shiki-dark:#C678DD;">==</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> GC_CONCURRENT_MARK) {</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // SATB invariant only maintained during concurrent marking</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    oop old_value </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">field;</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (old_value </span><span style="color:#C678DD;--shiki-dark:#C678DD;">!=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> null </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> !</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">is_marked</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(old_value)) {</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">      mark_object</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(old_value);</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      $</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">mark_stack</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">-&gt;</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">push</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(old_value);</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // scan all of old_value&#39;s fields later</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>这比原本的Yuasa式设计少了些东西：没有检查目标对象是否已经mark，也不去对目标对象做mark和扫描它的字段。实际上该做的事情还是得做，只是不在这里做而已。那放在那里做呢放到了后面的logging barrier，这个后面讲到。</p><p>Pre-write barrier的实际代码有好几个版本，其中最简单明白的版本是：</p><div class="language-cpp" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // This notes that we don&#39;t need to access any BarrierSet data</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // structures, so this can be called from a static context.</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  template</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> &lt;</span><span style="color:#C678DD;--shiki-dark:#C678DD;">class</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> T</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; </span><span style="color:#C678DD;--shiki-dark:#C678DD;">static</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> void</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> write_ref_field_pre_static</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">T</span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#E06C75;font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> field</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">oop</span><span style="color:#E06C75;font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> newVal</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    T heap_oop </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> oopDesc::</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">load_heap_oop</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(field);</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">!</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">oopDesc</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">::</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">is_null</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(heap_oop)) {</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">      enqueue</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">oopDesc</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">::</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">decode_heap_oop</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(heap_oop));</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  }</span></span></code></pre></div><p>enqueue动作的实际代码则在G1SATBCardTableModRefBS::enqueue(oop pre_val)。</p><p>它判断当前是否在concurrent marking phase用的是：</p><div class="language-cpp" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">JavaThread</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">::</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">satb_mark_queue_set</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">().</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">is_active</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">()</span></span></code></pre></div><h4 id="_6-4-2-logging-write-barrier" tabindex="-1"><a class="header-anchor" href="#_6-4-2-logging-write-barrier"><span>6.4.2 logging write barrier</span></a></h4><p>为了尽量减少write barrier对应用mutator性能的影响，G1将一部分原本要在barrier里做的事情挪到别的线程上并发执行。<br> 实现这种分离的方式就是通过logging形式的write barrier：mutator只在barrier里把要做的事情的信息记（log）到一个队列里，然后另外的线程从队列里取出信息批量完成剩余的动作。</p><p>以SATB write barrier为例，每个Java线程有一个独立的、定长的SATBMarkQueue，mutator在barrier里只把old_value压入该队列中。一个队列满了之后，它就会被加到全局的SATB队列集合SATBMarkQueueSet里等待处理，然后给对应的Java线程换一个新的、干净的队列继续执行下去。</p><p>并发标记（concurrent marker）会定期检查全局SATB队列集合的大小。当全局集合中队列数量超过一定阈值后，concurrent marker就会处理集合里的所有队列：把队列里记录的每个oop都标记上，并将其引用字段压到标记栈（marking stack）上等后面做进一步标记。</p><p>所以整个STAB过程讲完。</p><h2 id="_7-g1命令行选项与最佳实践" tabindex="-1"><a class="header-anchor" href="#_7-g1命令行选项与最佳实践"><span>7. G1命令行选项与最佳实践</span></a></h2><h3 id="_7-1-命令行选项" tabindex="-1"><a class="header-anchor" href="#_7-1-命令行选项"><span>7.1 命令行选项</span></a></h3><ul><li><strong><code>-XX:+UseG1GC</code></strong> 告诉JVM使用G1收集器</li><li><strong>-XX:MaxGCPauseMillis=200</strong> 设置最大GC目标最大停顿时间为200ms，这是一个软指标。JVM会最大努力去达到它，因此有时停顿时间会达不到设置目标。G1配置是200ms</li><li><strong>-XX:InitiatingHeapOccupancyPercent=45</strong> 启动并发标记标记百分比，当整堆内存使用量达到百分比时，G1使用它来触发一个基于整个堆的并发标记循环，而不仅仅是一个代。默念值是45%</li></ul><h3 id="_7-2-最佳实践" tabindex="-1"><a class="header-anchor" href="#_7-2-最佳实践"><span>7.2 最佳实践</span></a></h3><p>下面有几个关于使用G1的最佳实践</p><h4 id="_7-2-1-不要设置young-generation大小" tabindex="-1"><a class="header-anchor" href="#_7-2-1-不要设置young-generation大小"><span>7.2.1 <strong>不要设置Young Generation大小</strong></span></a></h4><p>因为显式通过-Xmn设置young generation大小将会干预G1收集器的默认行为</p><ul><li>G1将不再尊重设定的pause time,本质来说是因为设置young generation大小使得设定的pause time目标失效。</li><li>G1不再能够根据需要扩展和收缩young generation的空间。由于大小是固定的，所以不能更改大小。</li></ul><h4 id="_7-2-2-响应时间指标" tabindex="-1"><a class="header-anchor" href="#_7-2-2-响应时间指标"><span>7.2.2 <strong>响应时间指标</strong></span></a></h4><p>不要使用平均响应时间(ART)作为指标来设置<code>XX:MaxGCPauseMillis=&lt;N&gt;</code>，而要考虑设置90%以上时间都能达到目标的值。这意味着90%发出请求的用户不会经历高于目标的响应时间。记住，暂停时间是一个目标，并不能保证总能达到。</p><h4 id="_7-2-3-什么是evacuation-failure" tabindex="-1"><a class="header-anchor" href="#_7-2-3-什么是evacuation-failure"><span>7.2.3 <strong>什么是Evacuation Failure</strong></span></a></h4><p>当JVM在GC期间复制对象到Survior区或或者提升对象时，堆空间被耗尽，堆区域升级失败。堆无法扩展，因为它已经处于最大值。这种情况在-XX:+PrintGCDetails将会以TO空间溢出**(<code>to-space overflow</code>)**的形式表示。代价是十分昂贵的，因为</p><ul><li>GC仍然需要继续，所以必须释放空间</li><li>未成功复制的对象必须在适当的位置保留</li><li>对CSet中区域的rset的任何更新都必须重新生成</li><li>所有这些步骤都很昂贵。</li></ul><h4 id="_7-2-4-如何避免evacuation-failure" tabindex="-1"><a class="header-anchor" href="#_7-2-4-如何避免evacuation-failure"><span>7.2.4 <strong>如何避免Evacuation Failure</strong></span></a></h4><p>为了避免Evacuation Failure，考虑以下选项。</p><ul><li>增大堆（内存)大小</li><li><ul><li>增大**<code>-XX:G1ReservePercent=n</code>**，默认是10</li><li>G1会预留一部分内存，制造一个假天花板，当真正Evacuation Failure时还有内存可用。</li></ul></li><li>早点启动标记周期</li><li>增大并行标记的线程数，使用**<code>-XX:ConcGCThreads=n</code>**选项。</li></ul><h3 id="_7-3-完整的g1-gc开关列表" tabindex="-1"><a class="header-anchor" href="#_7-3-完整的g1-gc开关列表"><span>7.3 完整的G1 GC开关列表</span></a></h3><ul><li>-XX:+UseG1GC 使用G1 GC。</li><li>-XX:MaxGCPauseMillis=n 设置最大GC停顿时间，这是一个软目标，JVM会尽最大努力去达到它。</li><li>-XX:InitiatingHeapOccupancyPercent=n 启动并发标记循环的堆占用率的百分比，当整个堆的占用达到比例时，启动一个全局并发标记循环，0代表并发标记一直运行。默认值是45%。</li><li>-XX:NewRatio=n 新生代和老年代大小的比例，默认是2。</li><li>-XX:SurvivorRatio=n eden和survivor区域空间大小的比例，默认是8。</li><li>-XX:MaxTenuringThreshold=n 晋升的阈值，默认是15（一个存活对象经历多少次GC周期之后晋升到老年代)。</li><li>-XX:ParallelGCThreads=n 设置GC并发阶段的线程数，默认值与JVM运行平台相关。</li><li>-XX:ConcGCThreads=n 设置并发标记的线程数，默认值与JVM运行平台相关。</li><li>-XX:G1ReservePercent=n 设置保留java堆大小比例，用于防止晋升失败/Evacuation Failure,默认值是10%。</li><li>-XX:G1HeapRegionSize=n 设置Region的大小，默认是根据堆的大小动态决定，大小范围是[1M,32M]</li></ul><h2 id="_8-总结" tabindex="-1"><a class="header-anchor" href="#_8-总结"><span>8. 总结</span></a></h2><ul><li>G1把内存分成一块块的Region，每块的Region的大小都是一样的。</li><li>G1保留了YGC并加上了一种全新的MIXGC用于收集老年代。G1中没有Full GC，G1中的Full GC是采用serial old Full GC。在MIXGC中的Cset是选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。在YGC中的Cset是选定所有young gen里的region。通过控制young gen的region个数来控制young GC的开销。YGC与MIXGC都是采用多线程复制清除，整个过程会STW。</li><li>G1的低延迟原理在于其回收的区域变得精确并且范围变小了。</li><li>全局并发标记分的五个阶段。</li><li>用STAB来维持并发GC的准确性。</li><li>使用G1的最佳实践</li><li>G1 GC日志打印</li></ul><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章"><span>参考文章</span></a></h2><p><a href="https://zhuanlan.zhihu.com/p/52841787" target="_blank" rel="noopener noreferrer">G1 收集器原理理解与分析</a></p></div><!--[--><div class="sponsor" data-v-98f29c97><div id="drinks-box" data-v-98f29c97><div id="drinks-box-s" class="drinks-button left-100" data-v-98f29c97><div id="drinks-icons" class="left-100 tr3" data-v-98f29c97><div id="coffee-donate" class="icon-donate" data-v-98f29c97><span class="font-icon icon iconfont icon-hk-flutter" data-v-98f29c97></span> 赞助 </div></div><div id="drinks-button-box" class="tr3 left-100" data-v-98f29c97><div id="drinks-button-bg" class="left-100" data-v-98f29c97></div><div id="github-box" data-v-98f29c97><a href="https://github.com/OrageKK/sponsor-page" target="_blank" data-v-98f29c97>Github</a></div><ul id="donate-buttons" class="list tr3" data-v-98f29c97><li id="paypal_donate" data-v-98f29c97><a href="https://www.paypal.me/oragekk" target="_blank" data-v-98f29c97>Paypal</a></li><!-- <li id="btc_donate" class="donate-button">Bitcoin</li> --><li id="alipay_donate" class="donate-button" data-v-98f29c97>AliPay</li><li id="wechat_donate" class="donate-button2" data-v-98f29c97>WeChat</li></ul></div><div id="drinks-qrcodes" class="left-100 tr3" data-v-98f29c97><div id="drinks-qrcode" data-v-98f29c97></div></div></div></div></div><!--]--><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/MrjackC/mrjackc.github.io/edit/main/src/posts/Java/JavaJVM/java-jvm-gc-g1-supplement.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><!----></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 845886914@qq.com">MrJason</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/posts/Java/JavaJVM/java-jvm-gc-g1.html" aria-label="GC - Java 垃圾回收器之G1详解"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->GC - Java 垃圾回收器之G1详解</div></a><a class="route-link auto-link next" href="/posts/Java/JavaJVM/java-jvm-cms-gc.html" aria-label="GC - Java 垃圾回收器之CMS GC问题分析与解决"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">GC - Java 垃圾回收器之CMS GC问题分析与解决<!----></div></a></nav><div id="vp-comment" class="waline-wrapper" darkmode="false" style="display:block;"><div data-waline provider="Waline"><div class="wl-reaction"><div class="wl-reaction-title">你认为这篇文章怎么样？</div><ul class="wl-reaction-list"><!--[--><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_agree.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_look_down.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_sunglasses.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_pick_nose.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_awkward.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_sleep.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><!--]--></ul></div><div class="wl-comment"><!--v-if--><div class="wl-panel"><div class="wl-header item3"><!--[--><div class="wl-header-item"><label for="wl-nick">昵称</label><input id="wl-nick" class="wl-input wl-nick" name="nick" type="text" value></div><div class="wl-header-item"><label for="wl-mail">邮箱</label><input id="wl-mail" class="wl-input wl-mail" name="mail" type="email" value></div><div class="wl-header-item"><label for="wl-link">网址(可选)</label><input id="wl-link" class="wl-input wl-link" name="link" type="text" value></div><!--]--></div><textarea id="wl-edit" class="wl-editor" placeholder="请留言。(填写邮箱可在被回复时收到邮件提醒)"></textarea><div class="wl-preview" style="display:none;"><hr><h4>预览:</h4><div class="wl-content"></div></div><div class="wl-footer"><div class="wl-actions"><a href="https://guides.github.com/features/mastering-markdown/" title="Markdown Guide" aria-label="Markdown is supported" class="wl-action" target="_blank" rel="noopener noreferrer"><svg width="16" height="16" ariaHidden="true"><path d="M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z" fill="currentColor"></path></svg></a><button type="button" class="wl-action" title="表情" style="display:none;"><svg viewBox="0 0 1024 1024" width="24" height="24"><path d="M563.2 463.3 677 540c1.7 1.2 3.7 1.8 5.8 1.8.7 0 1.4-.1 2-.2 2.7-.5 5.1-2.1 6.6-4.4l25.3-37.8c1.5-2.3 2.1-5.1 1.6-7.8s-2.1-5.1-4.4-6.6l-73.6-49.1 73.6-49.1c2.3-1.5 3.9-3.9 4.4-6.6.5-2.7 0-5.5-1.6-7.8l-25.3-37.8a10.1 10.1 0 0 0-6.6-4.4c-.7-.1-1.3-.2-2-.2-2.1 0-4.1.6-5.8 1.8l-113.8 76.6c-9.2 6.2-14.7 16.4-14.7 27.5.1 11 5.5 21.3 14.7 27.4zM387 348.8h-45.5c-5.7 0-10.4 4.7-10.4 10.4v153.3c0 5.7 4.7 10.4 10.4 10.4H387c5.7 0 10.4-4.7 10.4-10.4V359.2c0-5.7-4.7-10.4-10.4-10.4zm333.8 241.3-41-20a10.3 10.3 0 0 0-8.1-.5c-2.6.9-4.8 2.9-5.9 5.4-30.1 64.9-93.1 109.1-164.4 115.2-5.7.5-9.9 5.5-9.5 11.2l3.9 45.5c.5 5.3 5 9.5 10.3 9.5h.9c94.8-8 178.5-66.5 218.6-152.7 2.4-5 .3-11.2-4.8-13.6zm186-186.1c-11.9-42-30.5-81.4-55.2-117.1-24.1-34.9-53.5-65.6-87.5-91.2-33.9-25.6-71.5-45.5-111.6-59.2-41.2-14-84.1-21.1-127.8-21.1h-1.2c-75.4 0-148.8 21.4-212.5 61.7-63.7 40.3-114.3 97.6-146.5 165.8-32.2 68.1-44.3 143.6-35.1 218.4 9.3 74.8 39.4 145 87.3 203.3.1.2.3.3.4.5l36.2 38.4c1.1 1.2 2.5 2.1 3.9 2.6 73.3 66.7 168.2 103.5 267.5 103.5 73.3 0 145.2-20.3 207.7-58.7 37.3-22.9 70.3-51.5 98.1-85 27.1-32.7 48.7-69.5 64.2-109.1 15.5-39.7 24.4-81.3 26.6-123.8 2.4-43.6-2.5-87-14.5-129zm-60.5 181.1c-8.3 37-22.8 72-43 104-19.7 31.1-44.3 58.6-73.1 81.7-28.8 23.1-61 41-95.7 53.4-35.6 12.7-72.9 19.1-110.9 19.1-82.6 0-161.7-30.6-222.8-86.2l-34.1-35.8c-23.9-29.3-42.4-62.2-55.1-97.7-12.4-34.7-18.8-71-19.2-107.9-.4-36.9 5.4-73.3 17.1-108.2 12-35.8 30-69.2 53.4-99.1 31.7-40.4 71.1-72 117.2-94.1 44.5-21.3 94-32.6 143.4-32.6 49.3 0 97 10.8 141.8 32 34.3 16.3 65.3 38.1 92 64.8 26.1 26 47.5 56 63.6 89.2 16.2 33.2 26.6 68.5 31 105.1 4.6 37.5 2.7 75.3-5.6 112.3z" fill="currentColor"></path></svg></button><button type="button" class="wl-action" title="表情包"><svg width="24" height="24" fill="currentcolor" viewBox="0 0 24 24"><path style="transform: translateY(0.5px)" d="M18.968 10.5H15.968V11.484H17.984V12.984H15.968V15H14.468V9H18.968V10.5V10.5ZM8.984 9C9.26533 9 9.49967 9.09367 9.687 9.281C9.87433 9.46833 9.968 9.70267 9.968 9.984V10.5H6.499V13.5H8.468V12H9.968V14.016C9.968 14.2973 9.87433 14.5317 9.687 14.719C9.49967 14.9063 9.26533 15 8.984 15H5.984C5.70267 15 5.46833 14.9063 5.281 14.719C5.09367 14.5317 5 14.2973 5 14.016V9.985C5 9.70367 5.09367 9.46933 5.281 9.282C5.46833 9.09467 5.70267 9.001 5.984 9.001H8.984V9ZM11.468 9H12.968V15H11.468V9V9Z"></path><path d="M18.5 3H5.75C3.6875 3 2 4.6875 2 6.75V18C2 20.0625 3.6875 21.75 5.75 21.75H18.5C20.5625 21.75 22.25 20.0625 22.25 18V6.75C22.25 4.6875 20.5625 3 18.5 3ZM20.75 18C20.75 19.2375 19.7375 20.25 18.5 20.25H5.75C4.5125 20.25 3.5 19.2375 3.5 18V6.75C3.5 5.5125 4.5125 4.5 5.75 4.5H18.5C19.7375 4.5 20.75 5.5125 20.75 6.75V18Z"></path></svg></button><input id="wl-image-upload" class="upload" aria-hidden="true" type="file" accept=".png,.jpg,.jpeg,.webp,.bmp,.gif"><label for="wl-image-upload" class="wl-action" title="上传图片" aria-label="上传图片"><svg viewBox="0 0 1024 1024" width="24" height="24"><path d="M784 112H240c-88 0-160 72-160 160v480c0 88 72 160 160 160h544c88 0 160-72 160-160V272c0-88-72-160-160-160zm96 640c0 52.8-43.2 96-96 96H240c-52.8 0-96-43.2-96-96V272c0-52.8 43.2-96 96-96h544c52.8 0 96 43.2 96 96v480z" fill="currentColor"></path><path d="M352 480c52.8 0 96-43.2 96-96s-43.2-96-96-96-96 43.2-96 96 43.2 96 96 96zm0-128c17.6 0 32 14.4 32 32s-14.4 32-32 32-32-14.4-32-32 14.4-32 32-32zm462.4 379.2-3.2-3.2-177.6-177.6c-25.6-25.6-65.6-25.6-91.2 0l-80 80-36.8-36.8c-25.6-25.6-65.6-25.6-91.2 0L200 728c-4.8 6.4-8 14.4-8 24 0 17.6 14.4 32 32 32 9.6 0 16-3.2 22.4-9.6L380.8 640l134.4 134.4c6.4 6.4 14.4 9.6 24 9.6 17.6 0 32-14.4 32-32 0-9.6-4.8-17.6-9.6-24l-52.8-52.8 80-80L769.6 776c6.4 4.8 12.8 8 20.8 8 17.6 0 32-14.4 32-32 0-8-3.2-16-8-20.8z" fill="currentColor"></path></svg></label><button type="button" class="wl-action" title="预览"><svg viewBox="0 0 1024 1024" width="24" height="24"><path d="M710.816 654.301c70.323-96.639 61.084-230.578-23.705-314.843-46.098-46.098-107.183-71.109-172.28-71.109-65.008 0-126.092 25.444-172.28 71.109-45.227 46.098-70.756 107.183-70.756 172.106 0 64.923 25.444 126.007 71.194 172.106 46.099 46.098 107.184 71.109 172.28 71.109 51.414 0 100.648-16.212 142.824-47.404l126.53 126.006c7.058 7.06 16.297 10.979 26.406 10.979 10.105 0 19.343-3.919 26.402-10.979 14.467-14.467 14.467-38.172 0-52.723L710.816 654.301zm-315.107-23.265c-65.88-65.88-65.88-172.54 0-238.42 32.069-32.07 74.245-49.149 119.471-49.149 45.227 0 87.407 17.603 119.472 49.149 65.88 65.879 65.88 172.539 0 238.42-63.612 63.178-175.242 63.178-238.943 0zm0 0" fill="currentColor"></path><path d="M703.319 121.603H321.03c-109.8 0-199.469 89.146-199.469 199.38v382.034c0 109.796 89.236 199.38 199.469 199.38h207.397c20.653 0 37.384-16.645 37.384-37.299 0-20.649-16.731-37.296-37.384-37.296H321.03c-68.582 0-124.352-55.77-124.352-124.267V321.421c0-68.496 55.77-124.267 124.352-124.267h382.289c68.582 0 124.352 55.771 124.352 124.267V524.72c0 20.654 16.736 37.299 37.385 37.299 20.654 0 37.384-16.645 37.384-37.299V320.549c-.085-109.8-89.321-198.946-199.121-198.946zm0 0" fill="currentColor"></path></svg></button></div><div class="wl-info"><div class="wl-captcha-container"></div><div class="wl-text-number">0 <span>  /  <span class="">300</span></span>  字</div><button type="button" class="wl-btn">登录</button><button type="submit" class="primary wl-btn" title="Cmd|Ctrl + Enter"><!--[-->提交<!--]--></button></div><div class="wl-gif-popup"><input type="text" placeholder="搜索表情包"><!--v-if--><div class="wl-loading"><svg width="30" height="30" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid"><circle cx="50" cy="50" fill="none" stroke="currentColor" strokeWidth="4" r="40" stroke-dasharray="85 30"><animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" values="0 50 50;360 50 50" keyTimes="0;1"></animateTransform></circle></svg></div></div><div class="wl-emoji-popup"><!--[--><!--]--><!--v-if--></div></div></div><!--v-if--></div><div class="wl-meta-head"><div class="wl-count"><!--v-if--> 评论</div><ul class="wl-sort"><!--[--><li class="active">按正序</li><li class="">按倒序</li><li class="">按热度</li><!--]--></ul></div><div class="wl-cards"><!--[--><!--]--></div><div class="wl-loading"><svg width="30" height="30" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid"><circle cx="50" cy="50" fill="none" stroke="currentColor" strokeWidth="4" r="40" stroke-dasharray="85 30"><animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" values="0 50 50;360 50 50" keyTimes="0;1"></animateTransform></circle></svg></div><div class="wl-power"> Powered by <a href="https://github.com/walinejs/waline" target="_blank" rel="noopener noreferrer"> Waline </a> v3.3.2</div></div></div><!----><!--]--></main><!--]--><div style="--0dfcb062:;"><footer class="footer-wrapper" style="display:none;"><div class="busuanzi"><span id="busuanzi_container_site_pv" style="display:none;"> 本站总访问量 <span id="busuanzi_value_site_pv"></span>次 <span class="post-meta-divider">|</span></span><span id="busuanzi_container_site_uv" style="display:none;"> 您是本站第 <span id="busuanzi_value_site_uv"></span>位访问者 </span></div><div class="footer-content"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2020-2024 MrJason</div></div><span id="runtime_span"></span><div class="footer-link"><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_1.gif" alt="" style="width:auto;height:32px;" title="穿梭虫洞-随机访问十年之约友链博客"></a><a href="https://www.travellings.cn/go.html" target="_blank"><img src="https://www.travellings.cn/assets/logo.gif" alt="" style="width:auto;height:32px;" title="开往-友链接力"></a></div></footer></div></div><!--]--><!--[--><!----><!----><div></div><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-DQS7qcOs.js" defer></script>
  </body>
</html>
