<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.12" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.46" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://mrjackc.github.io/posts/BigData/08_Spark/8.Spark%E5%86%85%E6%A0%B8.html"><meta property="og:site_name" content="mrjason’s Blog"><meta property="og:title" content="Spark内核"><meta property="og:description" content="Spark内核 所谓的内核，就是Spark内部核心原理。 一、内核解析的分解 Spark应用的提交 Spark内部的通信 Spark作业的调度 任务的执行 spark内存管理 二、 SparkSubmit 提交应用 2.1 Spark向yarn提交 2.1.1 SparkSubmit 2.2.2 yarn.YarnClusterApplication ..."><meta property="og:type" content="article"><meta property="og:image" content="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200619202433.png"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-10-28T01:58:08.000Z"><meta property="article:author" content="MrJason"><meta property="article:modified_time" content="2024-10-28T01:58:08.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Spark内核","image":["https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200619202433.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200618150421.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200618150442.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200618201029.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200618202126.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200618203801.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200618211748.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200620130734.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200621180817.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200620004312.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200620012427.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200620015214.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200620015026.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200620015251.png","https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200620015447.png"],"dateModified":"2024-10-28T01:58:08.000Z","author":[{"@type":"Person","name":"MrJason","url":"https://mrjackc.github.io"}]}</script><meta name="referrer" content="no-referrer-when-downgrade"><link rel="icon" href="/favicon.ico"><link rel="icon" href="/assets/icon/chrome-mask-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/assets/icon/chrome-mask-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/assets/icon/chrome-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/assets/icon/chrome-192.png" type="image/png" sizes="192x192"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><link rel="apple-touch-icon" href="/assets/icon/apple-icon-152.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileImage" content="/assets/icon/ms-icon-144.png"><meta name="msapplication-TileColor" content="#ffffff"><link rel="alternate" type="application/rss+xml" href="https://mrjackc.github.io/rss.xml" title="mrjason’s Blog RSS Feed"><title>Spark内核 | mrjason’s Blog</title><meta name="description" content="Spark内核 所谓的内核，就是Spark内部核心原理。 一、内核解析的分解 Spark应用的提交 Spark内部的通信 Spark作业的调度 任务的执行 spark内存管理 二、 SparkSubmit 提交应用 2.1 Spark向yarn提交 2.1.1 SparkSubmit 2.2.2 yarn.YarnClusterApplication ...">
    <link rel="preload" href="/assets/style-DFMGBKq-.css" as="style"><link rel="stylesheet" href="/assets/style-DFMGBKq-.css">
    <link rel="modulepreload" href="/assets/app-W9QyTiMU.js"><link rel="modulepreload" href="/assets/8.Spark内核.html-BQo6q4-u.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/logo.svg" alt><!----><span class="vp-site-name hide-in-pad">mrjason’s Blog</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="主页"><!--[--><span class="font-icon icon iconfont icon-home" style=""></span><!--]-->主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/demo/" aria-label="导航"><!--[--><span class="font-icon icon iconfont icon-discover" style=""></span><!--]-->导航<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="笔记分类"><!--[--><span class="font-icon icon iconfont icon-edit" style=""></span>笔记分类<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">代码笔记</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Computer-Basics/" aria-label="计算机基础"><!--[--><span class="font-icon icon iconfont icon-windows" style=""></span><!--]-->计算机基础<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Data-Structure/" aria-label="数据结构与算法"><!--[--><span class="font-icon icon iconfont icon-calculate" style=""></span><!--]-->数据结构与算法<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Web/" aria-label="前端笔记"><!--[--><span class="font-icon icon iconfont icon-code" style=""></span><!--]-->前端笔记<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Linux/" aria-label="Linux"><!--[--><span class="font-icon icon iconfont icon-linux" style=""></span><!--]-->Linux<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Python/" aria-label="Python"><!--[--><span class="font-icon icon iconfont icon-python" style=""></span><!--]-->Python<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Database/" aria-label="数据库"><!--[--><span class="font-icon icon iconfont icon-table" style=""></span><!--]-->数据库<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Docker/" aria-label="Docker"><!--[--><span class="font-icon icon iconfont icon-expansion" style=""></span><!--]-->Docker<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Git/" aria-label="Git"><!--[--><span class="font-icon icon iconfont icon-git" style=""></span><!--]-->Git<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Redis/" aria-label="Redis"><!--[--><span class="font-icon icon iconfont icon-lock" style=""></span><!--]-->Redis<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/MiddleWare/" aria-label="中间件"><!--[--><span class="font-icon icon iconfont icon-process" style=""></span><!--]-->中间件<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link route-link-active auto-link" href="/posts/BigData/" aria-label="大数据"><!--[--><span class="font-icon icon iconfont icon-hot" style=""></span><!--]-->大数据<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Architect/" aria-label="架构师"><!--[--><span class="font-icon icon iconfont icon-study" style=""></span><!--]-->架构师<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Daily-Thoughts/" aria-label="日常思考"><!--[--><span class="font-icon icon iconfont icon-mark" style=""></span><!--]-->日常思考<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/posts/Development-Tools/" aria-label="开发工具"><!--[--><span class="font-icon icon iconfont icon-tool" style=""></span><!--]-->开发工具<!----></a></li></ul></li><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">博客相关</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/blog/" aria-label="博客相关"><!--[--><span class="font-icon icon iconfont icon-blog" style=""></span><!--]-->博客相关<!----></a></li></ul></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/posts/Java/" aria-label="Java"><!--[--><span class="font-icon icon iconfont icon-java" style=""></span><!--]-->Java<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/collect.html" aria-label="收藏"><!--[--><span class="font-icon icon iconfont icon-hk-shoucang1" style=""></span><!--]-->收藏<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/news/" aria-label="说说"><!--[--><span class="font-icon icon iconfont icon-news" style=""></span><!--]-->说说<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/visitorsbook.html" aria-label="留言板"><!--[--><span class="font-icon icon iconfont icon-mark" style=""></span><!--]-->留言板<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/friend.html" aria-label="友链"><!--[--><span class="font-icon icon iconfont icon-link" style=""></span><!--]-->友链<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="关于"><!--[--><span class="font-icon icon iconfont icon-info" style=""></span>关于<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/intro.html" aria-label="关于我"><!--[--><span class="font-icon icon iconfont icon-people" style=""></span><!--]-->关于我<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/about.html" aria-label="关于本站"><!--[--><span class="font-icon icon iconfont icon-info" style=""></span><!--]-->关于本站<!----></a></li></ul></button></div></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/MrjackC/mrjackc.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://foreverblog.cn/go.html" title="穿梭虫洞-随机访问十年之约友链博客" target="_blank" rel="noopener noreferrer" aria-label="wormhole"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" fill="currentColor" style="width:1.25rem;height:1.25rem;vertical-align:middle"><path d="M644.608 665.6c192.512-171.008 342.016-395.776 254.464-494.592-27.648-31.232-66.56-45.568-108.032-41.472-34.816 3.584-70.656 20.992-107.008 50.176-116.224-59.904-254.464-55.296-366.592 11.776-86.016 51.2-148.48 134.656-172.544 231.936-18.944 74.24-14.336 152.064 12.8 223.744-44.544 50.688-86.528 154.624-34.816 212.992 21.504 24.576 52.736 35.328 90.112 35.328 114.176-0.512 286.72-100.864 431.616-229.888z m155.648-452.608c14.848-1.536 26.624 2.56 36.352 13.824 9.728 10.752 7.168 39.936-10.752 80.896-18.944-28.672-41.984-55.296-68.096-77.824 17.92-10.752 32.256-15.872 42.496-16.896z m-598.528 517.12c18.944 27.136 40.96 51.712 66.048 73.216-43.008 12.8-72.192 11.776-81.92 1.024-8.704-10.752 0.512-45.056 15.872-74.24z m685.568-246.784c-51.2 75.264-122.368 154.112-200.704 224.256-81.408 72.192-171.008 134.656-254.464 176.64 26.112 5.632 52.224 8.704 78.848 8.704 68.096 0 135.168-18.944 194.048-53.76 124.416-73.216 195.072-211.968 182.272-355.84z m0 0" p-id="4157"></path></svg></a></div><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://www.travellings.cn/go.html" title="开往" target="_blank" rel="noopener noreferrer" aria-label="travelling"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" fill="currentColor" style="width:1.25rem;height:1.25rem;vertical-align:middle"><path d="M658.836 519.32c-22.121 0-40.145 18.431-40.145 40.957 0 22.528 18.023 40.962 40.145 40.962 22.117 0 40.141-18.434 40.141-40.962 0-22.526-18.024-40.957-40.141-40.957zM364.742 519.32c-22.121 0-40.141 18.431-40.141 40.957 0.41 22.528 18.02 40.962 40.141 40.962 22.117 0 40.141-18.434 40.141-40.962 0-22.526-18.024-40.957-40.141-40.957z" p-id="8700"></path><path d="M512 0C229.23 0 0 229.23 0 512s229.23 512 512 512 512-229.23 512-512S794.77 0 512 0z m133.727 804.81c0 7.375-6.145 13.52-13.516 13.52H391.773c-7.371 0-13.515-6.145-13.515-13.52v-13.516c0-7.371 6.144-13.517 13.515-13.517h240.438c7.371 0 13.516 6.146 13.516 13.517v13.516z m120.832 37.273c-12.289 6.965-27.441 2.867-34.406-9.418l-54.887-96.668c-4.504 0.82-9.422 1.23-13.926 1.23H361.054c-4.914 0-9.421-0.41-13.925-1.23l-54.887 96.668c-6.965 12.285-22.527 16.383-34.406 9.418-12.289-6.961-16.383-22.938-9.422-35.223l51.199-90.113c-27.031-19.66-43.418-52.43-40.957-88.883l19.25-293.273c3.277-49.152 34.406-88.066 87.246-88.066h80.281c0-37.684 29.899-67.993 66.762-67.993 36.868 0 66.766 30.309 66.766 67.993h93.391c53.246 0 70.449 38.914 73.727 88.066l19.25 293.273c2.461 36.453-13.926 69.223-40.957 88.883l51.199 90.113c6.964 12.696 2.867 28.262-9.012 35.223z" p-id="8701"></path><path d="M672.352 314.931H351.633c-14.747 0-26.622 12.285-26.622 27.441v108.953c0 15.157 11.875 27.446 26.622 27.446h320.719c14.746 0 26.625-12.289 26.625-27.446V342.372c0-15.156-11.879-27.441-26.625-27.441z" p-id="8702"></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon" name="outlook"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="vp-outlook-dropdown"><!----></div></button></div><!--[--><div id="docsearch-container" style="display:none;"></div><div><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"><svg width="15" height="15" class="DocSearch-Control-Key-Icon"><path d="M4.505 4.496h2M5.505 5.496v5M8.216 4.496l.055 5.993M10 7.5c.333.333.5.667.5 1v2M12.326 4.5v5.996M8.384 4.496c1.674 0 2.116 0 2.116 1.5s-.442 1.5-2.116 1.5M3.205 9.303c-.09.448-.277 1.21-1.241 1.203C1 10.5.5 9.513.5 8V7c0-1.57.5-2.5 1.464-2.494.964.006 1.134.598 1.24 1.342M12.553 10.5h1.953" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="square"></path></svg></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/BigData/" aria-label="01 大数据生态圈"><!---->01 大数据生态圈<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">02 Hive总结</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">04 Flume总结</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">04 接入层</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">05 Zookeeper总结</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">05 数据处理层</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">06 Kafka总结</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">07 Scala总结</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">08 Spark</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/BigData/08_Spark/5.Spark%E4%B9%8BWordCount.html" aria-label="Spark 之 WordCount"><!---->Spark 之 WordCount<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/BigData/08_Spark/6.SparkSQL.html" aria-label="SparkSQL"><!---->SparkSQL<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/BigData/08_Spark/7.SparkStreaming.html" aria-label="SparkStreaming"><!---->SparkStreaming<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link vp-sidebar-page active" href="/posts/BigData/08_Spark/8.Spark%E5%86%85%E6%A0%B8.html" aria-label="Spark内核"><!---->Spark内核<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/BigData/08_Spark/4.%20Spark%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%94%B5%E5%95%86%E6%8C%87%E6%A0%87%E7%BB%9F%E8%AE%A1.html" aria-label="Spark实战项目——电商指标统计"><!---->Spark实战项目——电商指标统计<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/BigData/08_Spark/2.Spark%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%BC%96%E7%A8%8B.html" aria-label="Spark架构及编程"><!---->Spark架构及编程<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/BigData/08_Spark/1.Spark%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85.html" aria-label="Spark环境的安装"><!---->Spark环境的安装<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/posts/BigData/08_Spark/3.Spark%E7%BC%96%E7%A8%8B2.html" aria-label="Spark编程2"><!---->Spark编程2<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">10 Hbase</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">11 数仓</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Spark内核</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://mrjackc.github.io" target="_blank" rel="noopener noreferrer">MrJason</a></span><span property="author" content="MrJason"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-10-28T01:58:08.000Z"></span><span class="page-pageview-info" aria-label="访问量🔢" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon eye-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="eye icon" name="eye"><path d="M992 512.096c0-5.76-.992-10.592-1.28-11.136-.192-2.88-1.152-8.064-2.08-10.816-.256-.672-.544-1.376-.832-2.08-.48-1.568-1.024-3.104-1.6-4.32C897.664 290.112 707.104 160 512 160c-195.072 0-385.632 130.016-473.76 322.592-1.056 2.112-1.792 4.096-2.272 5.856a55.512 55.512 0 00-.64 1.6c-1.76 5.088-1.792 8.64-1.632 7.744-.832 3.744-1.568 11.168-1.568 11.168-.224 2.272-.224 4.032.032 6.304 0 0 .736 6.464 1.088 7.808.128 1.824.576 4.512 1.12 6.976h-.032c.448 2.08 1.12 4.096 1.984 6.08.48 1.536.992 2.976 1.472 4.032C126.432 733.856 316.992 864 512 864c195.136 0 385.696-130.048 473.216-321.696 1.376-2.496 2.24-4.832 2.848-6.912.256-.608.48-1.184.672-1.728 1.536-4.48 1.856-8.32 1.728-8.32l-.032.032c.608-3.104 1.568-7.744 1.568-13.28zM512 672c-88.224 0-160-71.776-160-160s71.776-160 160-160 160 71.776 160 160-71.776 160-160 160z"></path></svg><span id="ArtalkPV" class="vp-pageview waline-pageview-count" data-path="/posts/BigData/08_Spark/8.Spark%E5%86%85%E6%A0%B8.html" data-page-key="/posts/BigData/08_Spark/8.Spark%E5%86%85%E6%A0%B8.html">...</span></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 36 分钟</span><meta property="timeRequired" content="PT36M"></span><!----><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#一、内核解析的分解">一、内核解析的分解</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#二、-sparksubmit">二、 SparkSubmit</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-1-spark向yarn提交">2.1  Spark向yarn提交</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#三、spark内部组件及通信">三、Spark内部组件及通信</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-1-通信原理">3.1 通信原理</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-2-组件之间通信">3.2 组件之间通信</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#四、作业的调度">四、作业的调度</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-1-application">4.1 Application</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-2-逻辑代码">4.2 逻辑代码</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-3-job触发">4.3 job触发</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-4-stage">4.4 stage</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-5-task的切分">4.5 task的切分</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#五、任务的执行">五、任务的执行</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-1-任务包含的内容">5.1 任务包含的内容</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-2-序列化">5.2 序列化</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-3-任务的调度">5.3  任务的调度</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-4-任务的计算">5.4  任务的计算</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-5-shuffle">5.5 shuffle</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#六-、-spark内存管理">六 、 Spark内存管理</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-1-堆内内存和堆外内存">6.1 堆内内存和堆外内存</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-2-内存空间分配">6.2 内存空间分配</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content"><h1 id="spark内核" tabindex="-1"><a class="header-anchor" href="#spark内核"><span>Spark内核</span></a></h1><hr><blockquote><p>所谓的内核，就是Spark内部核心原理。</p></blockquote><h2 id="一、内核解析的分解" tabindex="-1"><a class="header-anchor" href="#一、内核解析的分解"><span>一、内核解析的分解</span></a></h2><ol><li>Spark应用的提交</li><li>Spark内部的通信</li><li>Spark作业的调度</li><li>任务的执行</li><li>spark内存管理</li></ol><h2 id="二、-sparksubmit" tabindex="-1"><a class="header-anchor" href="#二、-sparksubmit"><span>二、 SparkSubmit</span></a></h2><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--本章节讲述job提交应用以后，环境的准备工作。主要包含以下：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. spark向yarn提交job的过程</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. yarn中application、driver、executor、container是如何相互响应</span></span></code></pre></div><ul><li>提交应用</li></ul><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">bin/spark-submit \</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--class org.apache.spark.examples.SparkPi \</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--master yarn \</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--deploymode cluster \   表示yarn的集群模式</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">./examples/jars/spark-</span><span style="color:#D19A66;--shiki-dark:#D19A66;">examples_2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">12</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">-</span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">5</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.jar \</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">10</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 说明：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--master yarn 默认是采用yarn的客户端模式，但是在实际过程中，我们都是使用yarn的集群模式。</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">所以增加：</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--deploymode cluster \</span></span></code></pre></div><h3 id="_2-1-spark向yarn提交" tabindex="-1"><a class="header-anchor" href="#_2-1-spark向yarn提交"><span>2.1 Spark向yarn提交</span></a></h3><h4 id="_2-1-1-sparksubmit" tabindex="-1"><a class="header-anchor" href="#_2-1-1-sparksubmit"><span>2.1.1 SparkSubmit</span></a></h4><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--作用：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 解析参数</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 提交参数，初始数环境，并获取</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;org.apache.spark.deploy.yarn.YarnClusterApplication&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">的对象，调用对象的start方法</span></span></code></pre></div><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 执行SparkSubmit的mian方法</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 在main方法中：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">）、 new SparkSubmit</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">）、 </span><span style="color:#D19A66;--shiki-dark:#D19A66;">submit</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">doSubmit</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(args) </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt;执行提交程序,点击doSubmit</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          ①、 val appArgs </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> parseArguments(args)  </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt;解析参数，解析应用提交的参数，点击parseArguments</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                  a、</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">parse</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">args</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">asJava</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)   </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt;具体进行参数的解析，点击parse，返回参数的解析，方法的内部调用了handle方法</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                     	action</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> Option</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">action</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">).getOrElse(SUBMIT)，</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt;默认值为submit</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                  b、handle(opt: String, </span><span style="color:#C678DD;--shiki-dark:#C678DD;">value</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">: String) </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt;opt:参数的名称，value：参数的值。</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                      左边是参数  </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> 右边是赋值的变量</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                     // </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--master yarn =&gt; master</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                     // </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--deploy-mode cluster =&gt; deployMode</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                     // </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--class SparkPI(WordCount) =&gt; 【mainClass】</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">         		 &quot;如上为解析参数&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">         		 </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">         ②、</span><span style="color:#D19A66;--shiki-dark:#D19A66;">appArgs</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">action</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> match</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span><span style="color:#C678DD;--shiki-dark:#C678DD;">case</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> SparkSubmitAction</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">SUBMIT</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> submit(appArgs, uninitLog)</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt;点击submit</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                submit中又调用了doRunMain()，doRunMain()中调用了runMain()方法</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                  -- runMain(args, uninitLog)，运行主程序，在runmain()方法中：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                  </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.准备提交环境</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                  -- val (childArgs, childClasspath, sparkConf, childMainClass) = prepareSubmitEnvironment(args)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                  </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.设定当前类的加载器</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                  -- Thread.currentThread.setContextClassLoader(loader)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                  </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.通过类名加载这个类，</span><span style="color:#98C379;--shiki-dark:#98C379;">&#39;反射的方式&#39;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                  -- mainClass = Utils.classForName(childMainClass)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                  </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.创建第3步类的实例，并将类型转换为SparkApplication</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                  -- app: SparkApplication = mainClass.newInstance().asInstanceOf[SparkApplication]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                  </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                   childMainClass到底是谁？</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                       cluster模式：childMainClass </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> YARN_CLUSTER_SUBMIT_CLASS</span></span>
<span class="line"><span style="color:#56B6C2;--shiki-dark:#56B6C2;">                                   =</span><span style="color:#D19A66;--shiki-dark:#D19A66;">org</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">apache</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">spark</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">deploy</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">yarn</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">YarnClusterApplication</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                       client模式：childMainClass </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> args</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">mainClass</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">class SparkPI(WordCount)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                   5</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">YarnClusterApplication</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">start</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                   --  app.start(childArgs.toArray, sparkConf)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                   </span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">             &quot;如上为提交环境，并启动org.apache.spark.deploy.yarn.YarnClusterApplication&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2-2-yarn-yarnclusterapplication" tabindex="-1"><a class="header-anchor" href="#_2-2-2-yarn-yarnclusterapplication"><span>2.2.2 yarn.YarnClusterApplication</span></a></h4><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--作用：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 调用YarnClusterApplication的start方法，创建yarn的resourcemanagerClient，RM的客户端</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 执行RM客户端执行run方法</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 在run方法中，启动一个应用程序application，也就是一个进程，并提交应用程序，则会执行这个进程的main方法。</span></span></code></pre></div><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 通过反射调用start()方法，在start()方法中：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   -- 1）new Client(new ClientArguments(args), conf).run()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          ①new ClientArguments(args)，是配置参数的封装</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          ②new Client，在client类中的属性有：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">              --val yarnClient = YarnClient.createYarnClient，点击createYarnClient方法，在这个方法中：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                  -- YarnClient client = new YarnClientImpl()，点击YarnClientImpl类，在类中有一个属性</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                      rmclient：resourcemanagerClient</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                      -- protected ApplicationClientProtocol rmClient</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">          &quot;如上就是创建RM客户端对象&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">，接下来执行run方法</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          ③run()，RM客户端对象执行run方法，点击run，在run方法的内部：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">              1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 提交应用，返回应用的id。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">              -- this.appId = submitApplication()，点击submitApplication(),查看具体提交的过程</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                     1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 初始化hadoop的环境</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                  	 --yarnClient.init(hadoopConf)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  	 2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 启动yarn客户端,与yarn之间进行连接</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      				-- yarnClient.start()</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">      				3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. yarn客户端创建一个应用application</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      				--val newApp = yarnClient.createApplication()</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                     4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 获取应用的id，在yarn应用程序中，每一个应用都是有唯一的应用id</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      				-- appId = newAppResponse.getApplicationId()</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">      				5</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 提交yarn应用程序，提交的是什么呢？</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      				--yarnClient.submitApplication(appContext)，点击appContext</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      				   --// Set up the appropriate contexts to launch our AM</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      				         配置java虚拟机的启动参数，点击createContainerLaunchContext，</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      				         在这个方法的内部进行了command的封装：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      				         【集群模式】command </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> bin/java </span><span style="color:#D19A66;--shiki-dark:#D19A66;">org</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">apache</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">spark</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">deploy</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">yarn</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">ApplicationMaster</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                           【client模式】command </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> bin/java </span><span style="color:#D19A66;--shiki-dark:#D19A66;">org</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">apache</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">spark</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">deploy</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">yarn</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">ExecutorLauncher</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                      --val containerContext = createContainerLaunchContext(newAppResponse)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                      基本参数配置的封装</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                      --val appContext = createApplicationSubmissionContext(newApp, containerContext)</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2-3-yarn-applicationmaster" tabindex="-1"><a class="header-anchor" href="#_2-2-3-yarn-applicationmaster"><span>2.2.3 yarn.ApplicationMaster</span></a></h4><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 作用</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 封装ApplicationMaster的参数</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 根据参数，创建ApplicationMaster对象</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 执行ApplicationMaster的run方法，在run方法中，最后调用到runDriver方法，在这个方法中：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   a、启动用户的应用，并返回这个应用的</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;线程&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">，具体实现如下：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">           a、启动用户提交的应用程序；</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">           b、在ApplicationMaster中创建一个线程，线程的名称就是</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Driver&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">           c、启动这个线程，并执行run方法，在run方法中，就是执行我们提交的应用程序类的main方法</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">           d、返回这个</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Driver&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">线程</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    b、 执行一个方法，用于返回</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;sparkContext&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">的对象，如果没有返回，就不会执行下面的代码，当返回了这个上下文的对象以后：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    c、 ApplicationMaster通过ApplicationMaste的客户端，向ResourceManager注册自己，并申请资源</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    d、 分配资源，具体实现如下： </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            a、在ResourceManager端获取一个ApplicationMaster的客户端，返回一个分配器</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            b、分配器进行资源的分配：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                 a、ApplicationMaster的客户端申请一个分配器响应</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                 b、分配器响应返回所有被分配的容器container(资源列表)给到ApplicationMaster</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                 c、如果分配的资源列表的数量大于0，则对容器进行处理，处理的方式为：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                        1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.AM内部会创建一个线程，并调用线程的run方法，在run方法中循环遍历RM返回的可用容器，然后进行</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        对每个容器进行匹配，此时涉及到首选位置，</span><span style="color:#D19A66;--shiki-dark:#D19A66;">根据请求匹配选择哪些容器</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">首选位置的选择规则见首选位置说明</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                        2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 运行匹配后的资源，挨个遍历可用的容器，如果运行执行器的数量小于目标执行器的数量</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;假如需要4个执行</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">                        器，即为目标执行器，此时已经运行了2个执行器，即为运行执行器的数量，此时会启动下面的逻辑&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">，</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        那么在这个容器中会创建一个线程池，一个线程池container对应一个ExecutorRunnable，并调用了这个对象的</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        run方法，在这个线程池中，有一个nmClient(nameManagClient),说明AM能够找到NM，在这个run方法中，创建</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        NM的客户端，初始化NM，并启动容器container，在启动容器中，封装一个指令，   command：/bin/java</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        /</span><span style="color:#D19A66;--shiki-dark:#D19A66;">org</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">apache</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">spark</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">executor</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.CoarseGrainedExecutorBackend，并且启动了这个指令，显然是一个进程</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        ，CoarseGrainedExecutorBackend，粗粒度的执行器后台。</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. main方法，在main方法中，分三步骤：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">） 封装参数</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    --val amArgs = new ApplicationMasterArguments(args)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">）创建ApplicationMaster的对象</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    --master = new ApplicationMaster(amArgs)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">）执行run方法,点击run方法</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    --System.exit(master.run())</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">       ①run方法的实现，点击runImpl</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       	--runImpl()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            // 如果是client模式，执行：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            -- runExecutorLauncher()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">             // 如果是集群模式，执行，点击runDriver</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            -- runDriver</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">               1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 启动用户的程序,返回一个线程，点击startUserApplication</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">               --userClassThread = startUserApplication()</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                    1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 通过类加载器加载一个类，并获取这个类的main方法</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    -- val mainMethod = userClassLoader.loadClass(args.userClass).getMethod(&quot;main&quot;, classOf[Array[String]])</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                    2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 创建一个线程</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    -- val userThread = new Thread</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                    3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    -- userThread.setContextClassLoader(userClassLoader)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                    4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 设定线程的名字为driver，说明driver就是一个applicationMaster的一个线程</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    -- userThread.setName(&quot;Driver&quot;)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                    5</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 启动线程，执行线程的run方法，其实就是执行类userClass的main方法，userClass是哪个类呢？</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                       通过查到，就是我们提交应用的</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--class，sparkpi，或者是我们自定的类</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    -- userThread.start()</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                        -- mainMethod.invoke      </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                    6</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 返回用户线程</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    -- userThread</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">               2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. awaitResult等待结果，线程阻塞，等待对象(SparkContext)的返回</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">               --val sc = ThreadUtils.awaitResult(sparkContextPromise.future,Duration(totalWaitTime, TimeUnit.MILLISECONDS))</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                 </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">               3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 返回sparkContext以后，向rm进行注册AM：ApplicationMaster，点击registerAM()</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                --registerAM(host, port, userConf, sc.ui.map(_.webUrl))</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    ApplicationMaster的客户端向RM注册自己，并申请资源</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    --client.register(host, port, yarnConf, _sparkConf, uiAddress, historyAddress)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">               4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 返回RM分配的容器</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">               --createAllocator(driverRef, userConf)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                   // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.AM的客户端，</span><span style="color:#98C379;--shiki-dark:#98C379;">&#39;在RM端&#39;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">，创建分配器，返回一个分配器</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                   -- allocator = client.createAllocator</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                   // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.分配器分配资源，点击allocateResources</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                   -- allocator.allocateResources()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                          // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.AM的客户端，申请一个分配响应</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                          --val allocateResponse = amClient.allocate(progressIndicator)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                          // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.分配器响应获取所有被分配的容器container(资源列表)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                         --val allocatedContainers = allocateResponse.getAllocatedContainers()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                         // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.如果可分配的容器数量大于0，则调用处理可用容器的方法，点击handle方法</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                          --if (allocatedContainers.size &gt; 0) =&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            handleAllocatedContainers(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">allocatedContainers</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">asScala</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                               // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.内部会创建一个线程，并调用线程的run方法，在run方法中循环遍历RM返回的可用容器，然后进行</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                  对每个容器进行匹配，此时涉及到首选位置，</span><span style="color:#D19A66;--shiki-dark:#D19A66;">根据请求匹配选择哪些容器</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">首选位置的选择规则见</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                  首选位置说明。</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                               // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 运行匹配后的资源，点击runAllocatedContainers</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                               --runAllocatedContainers(containersToUse)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                      // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 挨个遍历可用的容器资源</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                       --for (container &lt;- containersToUse)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                       // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 每个容器中，如果运行执行器的数量小于目标执行器的数量，执行如下代码</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                       --runningExecutors.size() &lt; targetNumExecutors</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                       // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 线程池，在线程池的内部有：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                       --launcherPool.execute(new Runnable </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                            // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.执行的池子是一个线程池</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                            --launcherPool = ThreadUtils.newDaemonCachedThreadPool</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                       		// </span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.一个线程container对应一个ExecutorRunnable，并调用了这个对象的run方法</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                       		--new ExecutorRunnable...run()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                       		     // a、在ExecutorRunnable中：说明AM能够找到NM</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                       		     --nmClient，nodeManager</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                       		     // b、run()中：其实就是AM与NM建立连接</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                     // 创建NM的客户端</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                                     --nmClient = NMClient.createNMClient()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                     // 初始化NM</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                                     --nmClient.init(conf)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                      // 启动NM</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                                     -- nmClient.start()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                      // 启动容器，点击</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                                      --startContainer()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                           // NM启动容器，启动executor</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                                           --nmClient.startContainer(container.get, ctx)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                           // 封装指令，点击prepareCommand</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                                           --val commands = prepareCommand()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                                 	commands</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">/bin/java/</span><span style="color:#D19A66;--shiki-dark:#D19A66;">org</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">apache</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">spark</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">executor</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.CoarseGrainedExecutorBackend</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt;粗粒度的执行器后台，是一个进程</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                           //将封装好的指令传递到参数中</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                                           --ctx.setCommands(commands.asJava)</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 首选位置说明</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        --1. 移动数据不如移动计算。 </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        --2. 首选位置：有多个，和本地化级别有关。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        --3. 本地化级别：将数据和计算所在的位置称之为本地化</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">               1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 计算和数据在同一个Executor中，称之进程本地化</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">               2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 计算和数据在同一个节点中，称之节点本地化</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">               3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 计算和数据在同一个机架中，称之机架本地化</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">               4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 任意</span></span></code></pre></div><img src="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200618002757.png" alt="image-20200618002757465" style="zoom:50%;"><img src="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200618002929.png" alt="image-20200618002929263" style="zoom:50%;"><p>![image-20200619202433592](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200619202433.png)</p><h4 id="_2-2-4-coarsegrainedexecutorbackend" tabindex="-1"><a class="header-anchor" href="#_2-2-4-coarsegrainedexecutorbackend"><span>2.2.4 CoarseGrainedExecutorBackend</span></a></h4><blockquote><p>执行一次- bin/java org.apache.spark.executor.YarnCoarseGrainedExecutorBackend这个命令 就会执行一个新的进程，则是属于并行执行的感觉，和之前执行的内容是分开的。类似我们在Windows中开了一个微信和qq程序一样，各自执行，互不影响。</p></blockquote><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 作用：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   执行CoarseGrainedExecutorBackend</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;执行器后台&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">的main方法，在main方法中：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 首先封装一些参数</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 执行run方法，在run方法中：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 通过driver的URI，使得CoarseGrainedExecutorBackend与Driver进行关联</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 通过通信环境创建了一个终端，名字为executor，创建一个CoarseGrainedExecutorBackend对象并调用onstart方法：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">             1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 获取driver的引用</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">             2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. ExecutorBackend向driver发送消息，注册executor的消息，也称之为反向注册</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">             3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 在driver端会接收到这个消息，通过executor的引用，发送消息给到ExecutorBackend，注册executor成功 </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">             4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. ExecutorBackend接收driver返回的executor注册成功的消息，</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 说明：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   executor是一个计算对象，在这个对象里面有一个线程池，每一个线程来处理一个从driver端发送过来的任务</span></span></code></pre></div><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. commands</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">/bin/java/</span><span style="color:#D19A66;--shiki-dark:#D19A66;">org</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">apache</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">spark</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">executor</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.CoarseGrainedExecutorBackend,</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">	执行这个指令，那么是调用这个类的main方法。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. main方法中：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">       // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 首先是对一些参数进行封装</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">       // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 执行run方法 </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       -- run(driverUrl, executorId, hostname, cores, appId, workerUrl, userClassPath)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">           // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.通过driver的uri和Driver进行关联</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            --driver = fetcher.setupEndpointRefByURI(driverUrl)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.通过通信环境创建了一个终端，名字为executor，</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            在底层：Executor启动后会注册通信，并收到信息onStart，收到消息后，会执行通信对象CoarseGrainedExecutorBackend</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            的onStart方法，点击CoarseGrainedExecutorBackend</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            --env.rpcEnv.setupEndpoint(&quot;Executor&quot;, new CoarseGrainedExecutorBackend( env.rpcEnv, driverUrl, executorId, hostname, cores, userClassPath, env))</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.获取driver的引用</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                -- driver = Some(ref)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.ExecutorBackend向driver发送消息，注册executor的消息，也称之为反向注册</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                --ref.ask[Boolean](RegisterExecutor(executorId, self, hostname, cores, extractLogUrls))</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.在driver端会接收到这个消息，因为在driver端，有一个上下文的对象，sparkcontext，在这个类有一个属性：</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                   private</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> var _schedulerBackend: SchedulerBackend </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> _，点击SchedulerBackend，是一个trait，找到</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                   实现类：CoarseGrainedSchedulerBackend，在这个类中，有一个方法：receiveAndReply()：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                      // executor的引用，在driver端，发送消息给到ExecutorBackend，注册executor成功</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                      --executorRef.send(RegisteredExecutor)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                      </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                      // ExecutorBackend类中有一个recive方法，用来接收driver返回的executor注册成功的消息，executor是一</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                         个计算对象，在这个对象里面有一个线程池，每一个线程来处理一个从driver端发送过来的任务</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                     --executor = new Executor(executorId, hostname, env, userClassPath, isLocal = false)</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>![image-20200618150421861](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200618150421.png)</p><p>![image-20200618150442390](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200618150442.png)</p><h4 id="_2-2-5-总结" tabindex="-1"><a class="header-anchor" href="#_2-2-5-总结"><span>2.2.5 总结</span></a></h4><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 1. application是在一个nodemanager中container中，并且在这个container中创建了一个driver线程</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 2. 在一个nodemanager中，可以创建多个container，在每个container中，会创建ExecutorBackend对象，在这个对象中，会创建一个executor对象，在这个对象中一个线程池，一个线程用来处理driver发来的一个task，至于能同时执行多少个task，和executor中的core数量有关。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 3. ApplicationMaster周旋于Driver和ResourceManager之间</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 4. spark有两个进程，也就是两个分支</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    创建RM的客户端，创建AM，在AM中，创建Driver的线程</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">    &quot;分支1&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：此时会执行Driver线程的run方法，在run方法中就是执行了应用程序的main方法</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">    &quot;分支2&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：构建SparkContext上下文的对象，再向RM注册AM，然后申请资源和返回可用的资源，最后Driver进行资源的选择，按照首选位置的原则。</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    所以如下图片有一个错误：资源满足以后才执行main方法，实际上是创建了driver线程，还没有申请资源就已经开始执行main方法了。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 5. 进程、线程、对象</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">   &quot;进程&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：SparkSubmit、ApplicationMaster和CoarseGrainedExecutorBackend</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">   &quot;线程&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：Driver，但是我们一般称SparkContext称之为Driver</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">   &quot;对象&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：Executor和YarnClusterApplication</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 6. client和cluster模式的区别：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      Driver的位置不同，其余的逻辑是一样的。</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      Cluster：在集群中，在nodemanager中的AM对象中，是一个线程</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      client：在集群之外</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic GO/20200618155642.png" alt="image-20200618155642818" style="zoom:150%;"><h2 id="三、spark内部组件及通信" tabindex="-1"><a class="header-anchor" href="#三、spark内部组件及通信"><span>三、Spark内部组件及通信</span></a></h2><h3 id="_3-1-通信原理" tabindex="-1"><a class="header-anchor" href="#_3-1-通信原理"><span>3.1 通信原理</span></a></h3><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 通信原理 - IO - RPC</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 基本的网络通信：Socket, ServerSocket</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 通信框架：AKKA(旧),  Netty(新)(AIO)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 三种IO方式：BIO（阻塞式）, NIO（非阻塞式）, AIO（异步）</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. Linux, </span><span style="color:#C678DD;--shiki-dark:#C678DD;">windows</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">	在Linux系统上，AIO的底层实现仍使用EPOLL，与NIO相同，因此在性能上没有明显的优势；Windows的AIO底层实现良好，但是Netty开发人员并没有把Windows作为主要使用平台考虑。微软的windows系统提供了一种异步IO技术：IOCP（I/O CompletionPort，I/O完成端口）；Linux下由于没有这种异步IO技术，所以使用的是epoll（一种多路复用IO技术的实现）对异步IO进行模拟。所以在Linux上不建议使用AIO</span></span></code></pre></div><h3 id="_3-2-组件之间通信" tabindex="-1"><a class="header-anchor" href="#_3-2-组件之间通信"><span>3.2 组件之间通信</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 组件：Driver、executor</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 通信环境：NettyRpcEnvFactory() 创建环境工厂 创建环境</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   通过env</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">rpcEnv</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.setupEndpoint，将driver和executor终端放进rpcenv中，那么这个driver和executor就可以通信</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 组件之间的通信：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    a、通信终端共通类：</span><span style="color:#C678DD;--shiki-dark:#C678DD;">Endpoint</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    b、通信终端：RpcEndpoint(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">receive</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; 通信的终端，drive和executor,负责接收数据</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    c、通信终端引用：RpcEndpointRef(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">send</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,ask) </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; 通信终端的指代，负责发送和请求</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 一个终端的生命周期：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">The life-cycle of an </span><span style="color:#C678DD;--shiki-dark:#C678DD;">endpoint</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> is</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">创建终端-</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> 启动终端 -</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> 接收消息 -</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> 停止终端</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {constructor -</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> onStart -</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> receive</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">* -</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> onStop}</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">5</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;终端和终端的引用是如何关联的呢？&quot;</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. driver和executor都是通信终端</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 现假如是executor向drive发送数据，那么在executor端，通过driver的引用ref给到driver发消息</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 在driver中有一个接收器，</span><span style="color:#C678DD;--shiki-dark:#C678DD;">receive</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 同时driver给Executor发送消息时，在driver端有一个executor的引用，通过executor的引用给到executor发送消息。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        5</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 这样在发送消息的时候，就不用等待返回的结果。</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>![image-20200618201029135](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200618201029.png)</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 接收消息就是通过收件箱：Inbox</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 发送消息就是通过发件箱：outbox</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 一个终端：RpcEndpoint，只有一个收件箱，但是有N个发件箱。</span></span></code></pre></div><p>![image-20200618202126937](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200618202126.png)</p><h2 id="四、作业的调度" tabindex="-1"><a class="header-anchor" href="#四、作业的调度"><span>四、作业的调度</span></a></h2><h3 id="_4-1-application" tabindex="-1"><a class="header-anchor" href="#_4-1-application"><span>4.1 Application</span></a></h3><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. Yarn中会有application，提交任务以后，就会产生一个应用，并有一个唯一的应用id</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 在SparkConf中配置了setAppName(xxxx),设置应用的名字</span></span></code></pre></div><p>![image-20200618203801740](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200618203801.png)</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. SparkContext，是spark核心的对象，核心类，在这个核心类中的一些重要的参数有：</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  private</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> var _conf: SparkConf </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> _  </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- spark的关键参数</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  private</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> var _env: SparkEnv </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> _    </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- spark的环境，内部有NettyRpcEnv</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  private</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> var _schedulerBackend: SchedulerBackend </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> _   </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- spark的调度后台，Rpc后台信息交互对象</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  private</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> var _taskScheduler: TaskScheduler </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> _         </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 任务调度器</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  private</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> var _heartbeatReceiver: RpcEndpointRef </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> _    </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 指心跳接收器，通信终端的引用 </span></span>
<span class="line"><span style="color:#E06C75;--shiki-dark:#E06C75;">  @volatile</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> private</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> var _dagScheduler: DAGScheduler </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> _ </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 有向无环图调度器，负责job内部调度，负责阶段划分和任务的切分。</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> -- _conf：下滑线开头，表示内部的变量，不是规范，是早期C程序员默认遵守的规范。</span></span></code></pre></div><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. DAGScheduler ，spark非常核心的调度器。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">      1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.内部有一个对象,DAGSchedulerEventProcessLoop,</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;指事件调度的规则&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">，点击这个类：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    --private[spark] val eventProcessLoop = new DAGSchedulerEventProcessLoop(this)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.上面类继承于EventLoop,这个类中有一个属性：事件队列，用来存放事件</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">           BlockingQueue</span><span style="color:#E06C75;--shiki-dark:#E06C75;">[E]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：阻塞式队列</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">           LinkedBlockingDeque：双端队列</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        -- private val eventQueue: BlockingQueue[E] = new LinkedBlockingDeque[E]()</span></span></code></pre></div><p>![image-20200618211748700](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200618211748.png)</p><h3 id="_4-2-逻辑代码" tabindex="-1"><a class="header-anchor" href="#_4-2-逻辑代码"><span>4.2 逻辑代码</span></a></h3><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. RDD的创建： 从内存中/从文件中</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. RDD的转换： 转换算子(单value类型、双value类型、kv类型)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. RDD的行动： 行动算子</span></span></code></pre></div><h3 id="_4-3-job触发" tabindex="-1"><a class="header-anchor" href="#_4-3-job触发"><span>4.3 job触发</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> 调用行动算子后，触发作业的执行过程：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.sparkContext提交作业</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	--&gt; sc.runjob </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">	2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 有向无环图的调度器执行runjob</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	--&gt; dagScheduler.runJob </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">	3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 提交job</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	--&gt; submitjob</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">	4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 消息队列进行存放消息</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	--&gt; eventProcessLoop.post</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">	5</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 消息队列将消息放进队列中，这个消息是：JobSubmitted</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	--&gt; eventQueue.put(event) </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">	6</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 在eventQueue里面有一个线程，线程中有一个run方法,在这个线程进行死循环(不会阻塞到主线程),不断取出消息</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	--&gt; eventThread.start()</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">	7</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.  子线程的run中负责取出消息，因为这个队列是一个阻塞式队列，队列中没有消息，那么就处于阻塞式状态</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	--&gt; val event = eventQueue.take() </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">	8</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 取到消息</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	--&gt; onReceive(event)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">	9</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 执行处理消息</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	--&gt; doOnReceive(event)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">	10</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 通过使用模式匹配的的方式处理消息(JobSubmitted事件会被下面匹配到)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	--&gt;  def doOnReceive(event: DAGSchedulerEvent): Unit = event match {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      		-- case JobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        11</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 有向无环图调度器处理任务的提交 (JobSubmitted事件会被下面匹配到执行下面的操作)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        --&gt; dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        	涉及到stage的划分</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        	 11</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.1创建stage(最后的一个result stage)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		--finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)  //resultstage和finalstage是一个东西</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">		11</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.2每个shuffle依赖创建一个ShuffleMapStage</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		-- getOrCreateParentStages</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		    -- getShuffleDependencies(rdd).map { shuffleDep =&gt;getOrCreateShuffleMapStage(shuffleDep, firstJobId) }.toListshufflestage</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                    </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        12</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 创建一个活动的job</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        --&gt; val job = new ActiveJob</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        finalStage</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">setActiveJob</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(job)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">	submitStage(finalStage)</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 总结：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">启动一个行动算子 </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; runjob  -&gt; 将执行事件放进阻塞式队列中 -&gt; 创建一个线程取出队列中的消息 -&gt; 进行模式匹配，处理任务的提交</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; 创建一个运行job</span></span></code></pre></div><h3 id="_4-4-stage" tabindex="-1"><a class="header-anchor" href="#_4-4-stage"><span>4.4 stage</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 1. 阶段的划分，取决于转换算子的依赖类型。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 2. 宽依赖：ShuffleDependency</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 3. 窄依赖：OneToOneDependency extends NarrowDependency</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 4. 分区的数量</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">     a、窄依赖：分区数量保持不变</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">          1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 获取窄依赖的分区数量，点击 firstParent</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          -- override def getPartitions: Array[Partition] = firstParent[T].partitions</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">               1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 获取依赖关系的第一个rdd分区数量</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">               -- dependencies.head.rdd.asInstanceOf[RDD[U]]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">     b、宽依赖：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">            1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 获取宽依赖的分区数量</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            partitioner：是一个分区器，partitioner，由上一个RDD传递过来的，在传递的时候，会进行判断，如果当前的RDD的分区器</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            和上一级的分区器一样，那么是不会创建shuffleRDD，只有当前RDD的分区器和上一级的分区器不一样时，才会创建</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            ShuffledRDD</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            --Array.tabulate[Partition](part.numPartitions)(i =&gt; new ShuffledRDDPartition(i))</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">            2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 默认情况下，默认的分区器将上一级的RDD传入</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            --  reduceByKey(defaultPartitioner(self), func)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 默认的分区数量等于上级RDD的最大值，因为上一级RDD可能有多个</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                -- val defaultNumPartitions = rdds.map(_.partitions.length).max</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 构造分区器的时候，将默认的分区数量传入，分区器的作用是指定数据去到哪个分区，分区的数量默认和上一级RDD</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                   保持一致</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                -- new HashPartitioner(defaultNumPartitions)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> -- 5. 总结： </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">       a、窄依赖默认分区数量保持不变</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">       b、宽依赖，默认和上一级	RDD最大的分区数量保持一致，如果上一级RDD只有一个，那就和上一级RDD保持一致</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                 但是Shuffle的算子一般都会有改变分区数量的参数</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 6. 从文件中创建RDD时默认的分区数量</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">      1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 取(defaultParallelism, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)的最小值，点击defaultParallelism</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      --math.min(defaultParallelism, 2)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">      2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 选择yarn模式中的默认平行度。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      --defaultParallelism = conf.getInt(&quot;spark.default.parallelism&quot;, math.max(totalCoreCount.get(), 2))</span></span></code></pre></div><p>![image-20200620130734058](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200620130734.png)</p><h3 id="_4-5-task的切分" tabindex="-1"><a class="header-anchor" href="#_4-5-task的切分"><span>4.5 task的切分</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--1. 任务和阶段stage的关系</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">     定位：DAGScheduler类</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">     1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 处理任务的提交handleJobSubmitted，在这个方法的内部：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 将整个job作为一个finalStage</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    	-- var finalStage: ResultStage = null</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    	2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 创建一个结果阶段，并赋值给finalStage</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    	    finalRDD：最后提交job时的RDD，点击createResultStage</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    	-- finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    	    1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 通过当前的RDD获取其上一级的阶段，点击getOrCreateParentStages</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    	    -- val parents = getOrCreateParentStages(rdd, jobId)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    	         1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.获取最后一个RDD的shuffle依赖，每一个shuffle依赖创建一个shufflemapStage</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    	         --getShuffleDependencies(rdd).map { shuffleDep =&gt;getOrCreateShuffleMapStage(shuffleDep, firstJobId)}.toList</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    	          a. 在getShuffleDependencies方法中，找到resultStage的上一级shuffleRDD</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    	           val parents </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> new HashSet</span><span style="color:#E06C75;--shiki-dark:#E06C75;">[ShuffleDependency[_, _, _]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">] </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 存放宽依赖</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    val visited </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> new HashSet</span><span style="color:#E06C75;--shiki-dark:#E06C75;">[RDD[_]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">] </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--创建一个hashSet集合，用来存放已经被访问过的RDD</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    val waitingForVisit </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> new ArrayStack</span><span style="color:#E06C75;--shiki-dark:#E06C75;">[RDD[_]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">] </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 集合的栈，创建一个集合，用来存放待访问的RDD</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                    waitingForVisit</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">push</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(rdd)    </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 将最后的一个RDD传到这个集合中</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                    while</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (</span><span style="color:#D19A66;--shiki-dark:#D19A66;">waitingForVisit</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">nonEmpty</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) { </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 集合是否为空，刚放进去，肯定不是空</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                      val toVisit </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> waitingForVisit</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">pop</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">()  </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- pop，弹栈，将刚刚放进去的RDD弹出来，并准备去访问</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                      if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (!visited(toVisit)) {  </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 当前放进去的RDD是否被访问过，如果没有，则继续向下执行</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        visited +</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> toVisit      </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 将当前获取的RDD放进已经被访问的RDD集合中</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                        toVisit</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">dependencies</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.foreach {  </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 获取RDD与直接上级的RDD的依赖关系，并循环遍历。</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                          case</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> shuffleDep: ShuffleDependency</span><span style="color:#E06C75;--shiki-dark:#E06C75;">[_, _, _]</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =&gt;</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> -- 如果是宽依赖</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            parents +</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> shuffleDep  </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 则将依赖加入parents集合中</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                          case</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> dependency </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=&gt;</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                            waitingForVisit</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">push</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">dependency</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">rdd</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 如果是窄依赖，将上级RDD放进等待访问的RDD中，并</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                                 进行循环，判断其与上级RDD的依赖关系，直到当前的RDD为</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                                 shuffleRDD</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                             }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                      }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    parents   </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 将上一级shuffleRDD放进parents的集合中</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    获取当前RDD与直接上级的RDD的依赖关系，返回一个seq序列集合，因为当前的RDD的直接上级的RDD可能有多个</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    -- toVisit.dependencies</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                 b、通过map方法，对resultStage上级的shuffleRDD进行遍历，调用如下方法：返回获取的ShuffleDependency，执行获取或创建shuffleMapStage，点击这个方法</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    -- getOrCreateShuffleMapStage</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        创建shuffleMapStage，每一个shuffleDep创建一个shuffleMapStage</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                        -- createShuffleMapStage(shuffleDep, firstJobId)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            new出一个shuffleMapStage</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            // 将依赖的上一级RDD赋值给rdd</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                            --val rdd = shuffleDep.rdd</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            // 又调用了创建或获取上一级阶段</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                            -- val parents = getOrCreateParentStages(rdd, jobId)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                            -- val stage = new ShuffleMapStage</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--2. 阶段的类型</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   ResultStage 和 shuffleMapStage</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--3. 阶段的数量</span></span>
<span class="line"><span style="color:#56B6C2;--shiki-dark:#56B6C2;">   =</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ResultStage  + n *  shuffleMapStage</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--4. 任务和分区的关系</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">     1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 提交最后一个阶段：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       --submitStage(finalStage)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">           1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 获取当前阶段的上一级阶段</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">           --  val missing = getMissingParentStages(stage).sortBy(_.id)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">           2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 如果有上一级阶段不为空，则循环遍历上一阶段，先假如上一级阶段只有一个，则提交上一个阶段，又调用提交阶段</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">           --for (parent &lt;- missing) {submitStage(parent)}</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">           </span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">  &quot;总结：在提交阶段时，从最后一个阶段往前找，直到最前面的一个阶段，然后再依次从前往后进行提交阶段&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">。             </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 当没有上一级阶段以后，提交任务</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       -- submitMissingTasks(stage, jobId.get)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.对当前阶段进行模式匹配，确认是shuffleMapSrage还是ResultStage，返回结果为taskIdToLocations,任务本地化路径</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 如果当前阶段是ShuffleMapStage，则创建ShuffleMapTask</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                如果当前阶段是ResultStage ，则创建ResultTask</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">           val tasks: Seq</span><span style="color:#E06C75;--shiki-dark:#E06C75;">[Task[_]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">] </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> try</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">           </span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                case</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> stage: ShuffleMapStage</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                {........</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                 partitionsToCompute</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">map</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  --&gt; 计算分区的数量，每一个分区，会执行如下创建任务的代码。</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                new ShuffleMapTask(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">stage</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">id</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">stage</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">latestInfo</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.attemptNumber</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                .....}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">               case</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> stage: ResultStage </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                {                   </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                .......</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">		partitionsToCompute</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">map</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  --&gt; 计算分区的数量，每一个分区，会执行如下创建任务的代码。</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                new ResultTask(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">stage</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">id</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">stage</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">latestInfo</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.attemptNumber,</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                .......</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                       }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 5. task的类型：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      a、如果当前阶段是ShuffleMapStage，则创建ShuffleMapTask</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      b、如果当前阶段是ResultStage ，则创建ResultTask</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 6 .任务的总数量</span></span>
<span class="line"><span style="color:#56B6C2;--shiki-dark:#56B6C2;">      =</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> 每个阶段的任务总和</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--总结：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 通过resultStage最后一个RDD，进行循环依次向上找，获取resultStage阶段，上一级为shuffleDep的ShuffleDependency，</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   存放到一个parents集合中</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 采用map算子，parents集合中的每个ShuffleDependency，获取到所有上级依赖为shuffleDep的RDD，然后每一个shuffleDep会创建</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">一个ShuffleMapStage阶段。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 当找到job最前面一个RDD以后，开始从第一个阶段提交阶段，提交阶段时，首先获取当前阶段最后一个RDD的分区数量，在一个阶段中，每一个分区就会创建一个task，task的类型和阶段的类型匹配：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      a、如果当前阶段是ShuffleMapStage，则创建ShuffleMapTask</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      b、如果当前阶段是ResultStage ，则创建ResultTask</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 当前阶段提交完成以后，就提交下一个阶段，依次类推，最后就会提交resultStage。</span></span></code></pre></div><h2 id="五、任务的执行" tabindex="-1"><a class="header-anchor" href="#五、任务的执行"><span>五、任务的执行</span></a></h2><h3 id="_5-1-任务包含的内容" tabindex="-1"><a class="header-anchor" href="#_5-1-任务包含的内容"><span>5.1 任务包含的内容</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">  1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.任务的提交：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  --new ShuffleMapTask(stage.id, stage.latestInfo.attemptNumber,taskBinary, part, locs, properties, serializedTaskMetrics, Option(jobId),Option(sc.applicationId), sc.applicationAttemptId, stage.rdd.isBarrier())</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">  2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 提交的重要几个参数有：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">     a、</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;stage.id&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：任务从属的阶段id</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">     b、</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;taskBinary&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：是一个广播变量，内容为：阶段的</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;RDD&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">和</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;依赖关系&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">序列化以后的二进制字节码，因为RDD是不保存数据，一旦任务执行失败，需要知道RDD的元数据信息以及依赖关系，才能进行重新计算。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">         1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 是一个广播变量</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">         --var taskBinary: Broadcast[Array[Byte]] = null</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">         2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 将任务的二进制的字节码赋值给了这个广播变量</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">         --taskBinary = sc.broadcast(taskBinaryBytes)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">         3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 任务的二进制的字节码是通过对阶段匹配，如果是shuffle阶段，就会采用闭合的序列化器将阶段的RDD和阶段的依赖进行序列化</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">         --taskBinaryBytes = stage match {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">           case</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> stage: ShuffleMapStage </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=&gt;</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                JavaUtils</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">bufferToArray</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  closureSerializer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">serialize</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">((</span><span style="color:#D19A66;--shiki-dark:#D19A66;">stage</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">rdd</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">stage</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">shuffleDep</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): AnyRef))</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">             case</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> stage: ResultStage </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=&gt;</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">            	JavaUtils</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">bufferToArray</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">closureSerializer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">serialize</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">((</span><span style="color:#D19A66;--shiki-dark:#D19A66;">stage</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">rdd</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">stage</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">func</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">): AnyRef))</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      c、 </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;part&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ：分区，指当前的task和哪个partition有关</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          -- val part = partitions(id)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      d、 </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;locs&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> ： 任务的首选位置</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          -- val locs = taskIdToLocations(id)</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-2-序列化" tabindex="-1"><a class="header-anchor" href="#_5-2-序列化"><span>5.2 序列化</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 默认的序列化：</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;JavaSerializer&quot;</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 在SparkContext中创建了SparkEnv，点击创建的方法，一层一层往里点：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    -- _env = createSparkEnv(_conf, isLocal, listenerBus)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 最终看到了默认的序列化器为：JavaSerializer</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        --val serializer = instantiateClassFromConf[Serializer](</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">      		&quot;spark.serializer&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;org.apache.spark.serializer.JavaSerializer&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   				 logDebug(s</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Using serializer: ${serializer.getClass}&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. kryo序列化:</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      --1.特点：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          a、性能优</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          b、序列化结果文件的字节数少</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          c、可以绕过java的序列化，将不能序列的对象也能进行序列化</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          d、但是，我们在实际的情况下，并不是所有的对象都会采用kryo序列化。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     --2. 那么哪些对象采用kryo序列化会比较有优势呢？</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">          &quot;总结：在shuffle阶段，当为kv类型时，k、v的数据类型如果都支持kryo序列，则会采用kryo进行序列化。</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">                支持ktyo序列化的数据类型有：String和值类型(anyVal)&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">         底层：当有shuffle阶段时，会选择最好的序列化器</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">         -- Pick the best serializer for shuffling an RDD of key-value pairs.</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">         2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 判断选择的规则：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            如果kv的k和v都能使用kryo序列化器时，则选择kryo序列化器，否则选择默认的序列化器：javaSerializer</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            当为如下类型（值类型）或者是string类型的时候，则可以使用kyro序列化器</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            --if (canUseKryo(keyClassTag) &amp;&amp; canUseKryo(valueClassTag)) {</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">              kryoSerializer</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            } </span><span style="color:#C678DD;--shiki-dark:#C678DD;">else</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">              defaultSerializer</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">              --  ClassTag.Boolean,</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  ClassTag</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">Byte</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  ClassTag</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">Char</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  ClassTag</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">Double</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  ClassTag</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">Float</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  ClassTag</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">Int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  ClassTag</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">Long</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  ClassTag</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">Null</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  ClassTag</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">Short</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-3-任务的调度" tabindex="-1"><a class="header-anchor" href="#_5-3-任务的调度"><span>5.3 任务的调度</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 1. driver生成的任务以后存放在哪里了？</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   a、当driver生成任务以后，并不是立即将任务task就发送给executor，因为可能发送过程有异常，也可能发送过去的时候，executor对象还没有创建，都会导致任务task发送失败</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">      1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 一个阶段stage生成tasks以后，如果这个阶段的tasks的数量大于0，那么这个任务调度器就会提交任务，在提交任务中，会将这个</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">          stage的任务封装成一个TaskSet,任务集进行提交，点击submitTasks</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      -- if (tasks.size &gt; 0)，taskScheduler.submitTasks(new TaskSet( tasks.toArray, stage.id, stage.latestInfo.attemptNumber, jobId, properties))</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">              1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.首先取出任务</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">              --val tasks = taskSet.tasks</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">              2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 创建一个任务集taskset的管理者manager</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">              -- val manager = createTaskSetManager(taskSet, maxTaskFailures)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">              3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 构建调度器，将刚刚创建的任务集管理者放到调度器中，点击addTaskSetManager</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">              --schedulableBuilder.addTaskSetManager(manager, manager.taskSet.properties)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                  1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.是一个抽象方法，类是一个trait，有两个实现类，分别是：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        FIFOSchedulableBuilder </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; 先进先出调度器</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        FairSchedulableBuilder </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; 公平调度器</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        那么我们新增加进去的manager是采用什么调度器呢？</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            a、通过源码可知，默认的调度模式为FIFO模式</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                            -- private val schedulingModeConf = conf.get(SCHEDULER_MODE_PROPERTY, SchedulingMode.FIFO.toString)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            b、创建一个任务调度池，当driver生成任务以后，会将任务放进任务池中，由manager来进行调度</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            val rootPool: </span><span style="color:#C678DD;--shiki-dark:#C678DD;">Pool</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> new </span><span style="color:#C678DD;--shiki-dark:#C678DD;">Pool</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, schedulingMode, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                   2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 将manager直接放进调度池中，</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                    rootPool</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">addSchedulable</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(manager)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. </span><span style="color:#D19A66;--shiki-dark:#D19A66;">点击</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">reviveOffers</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：恢复当前的操作</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">               --backend.reviveOffers()</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                   1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.driver的终端，自己给自己发消息</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    -- driverEndpoint.send(ReviveOffers)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                    2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.在DriverEndpoint中，就有一个receive方法，在这个方法中，匹配获取的消息，如果是ReviveOffers,</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    则执行makeOffers()方法，点击makeOffers()方法</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                     -- case ReviveOffers =&gt;makeOffers()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                         a、DriverEndpoint调度器从任务池中取出任务，取任务的具体方式：点击resourceOffers</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                          -- val taskDescs = scheduler.resourceOffers(workOffers)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                               a、获取一个排好序的任务集合，实现方式，点击getSortedTaskSetQueue</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                --val sortedTaskSets = rootPool.getSortedTaskSetQueue</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                     a、如下为任务集的调度的算法，依据算法对任务集进行比较排序，返回排好序的任务集，然后将</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                     返回任务集存放到一个arraybuffer集合中，并返回给到sortedTaskSets，不同的调度的算法</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                     是不一样的。</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">                                     &quot;FIFO调度算法&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：先比较优先级，优先级高的先调度，如果优先级相等，则比较阶段id，阶段</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                    id小的先执行。</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">                                     &quot;Fair调度算法&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：根据运行任务的数量、权重【默认值为1】、最小分配数量【默认值为0】，</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                                    进行综合分配</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                      -- val sortedSchedulableQueue =</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">      schedulableQueue</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">asScala</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">toSeq</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">sortWith</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">taskSetSchedulingAlgorithm</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">comparator</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                         b、如果任务不为空，则driver发射任务</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                          -- if (!taskDescs.isEmpty) {launchTasks(taskDescs)}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 1.总结</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 一个stage生成tasks以后，由taskSchedule负责任务的调度</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 一个stage就会有一个任务集，taskSet</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 每一个taskSet都会被封装成TaskSetManager，负责监控管理同一个Stage中的Tasks，TaskScheduler调度模式有两种：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        a、FIFOSchedulableBuilder </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; 先进先出调度器【默认调度模式】</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        b、FairSchedulableBuilder </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; 公平调度器</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. TaskScheduler初始化过程中会实例化rootPool任务池，driver准备的任务和管理者会发送到这个任务池中，</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      由TaskScheduler负责将任务调度结果发送给executor</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   5</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. driver的终端自己给自己发送一个消息</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;ReviveOffers&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">，driverEndpoint收到ReviveOffer消息后调用makeOffers方法，TaskScheduler就开始进行任务集的调度</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   6</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 根据</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;调度算法&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">对任务集进行排序，获取一个排好序的队列</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;排序在前的就先执行，排序在后的就后执行&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">，将排好序的队列放到一个arraybuffer集合中，并返回给到sortedTaskSets</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">       </span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">       &quot;FIFO调度算法&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：先比较优先级，优先级高的先调度，如果优先级相等，则比较阶段id，阶段 id小的先执行。</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">        &quot;Fair调度算法&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：根据运行任务的数量、</span><span style="color:#C678DD;--shiki-dark:#C678DD;">weight</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">【默认值为1】、minShare【默认值为0】，进行综合分配</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        minShare、weight的值均在公平调度配置文件</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;fairscheduler.xml&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">中被指定，调度池在构建阶段会读取此文件的相关配置</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   7</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;driverEndpoint&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">调度器就从这个排好序的任务队列的数组中取任务tasks。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   8</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 如果获取的任务不为空，则dirver开始发射任务</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 2.说明：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 从任务池中取出的任务，包含了本地化级别信息以及等待的时长(</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;默认每个级别等待时间为3s，也可以单独设置每个级别的等待时间&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)，当在driver在发送任务的时候，会根据本地化级别进行发送任务.</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 3.区分本地化级别和调度算法</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    调度算法：是指driverEndpoint在调度任务集时，确定哪个任务集先执行，哪个任务集后执行</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    本地化级别：是指driver在发送向executor发送任务的首选位置，确定任务发送到哪个executor中，如果发送不成功，并进行降级处理</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-4-任务的计算" tabindex="-1"><a class="header-anchor" href="#_5-4-任务的计算"><span>5.4 任务的计算</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. driver发送任务前，会将任务进行编码：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    	--val serializedTask = TaskDescription.encode(task)  </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 然后向executor发送已经编码和序列化的任务task</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   		-- executorData.executorEndpoint.send(LaunchTask(new SerializableBuffer(serializedTask))</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 在executorbackend就会收到任务(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">receive</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)并启动任务,首先是对任务进行解码，然后executor启动任务，点击launchTask</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    	--val taskDesc = TaskDescription.decode(data.value)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        logInfo(</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Got assigned task &quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> + </span><span style="color:#D19A66;--shiki-dark:#D19A66;">taskDesc</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">taskId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        executor</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">launchTask</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(this, taskDesc)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.  来一个task就使用一个线程来接收</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        --val tr = new TaskRunner(context, taskDescription)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        runningTasks</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">put</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">taskDescription</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">taskId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, tr)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">        threadPool</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">execute</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(tr)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">    5</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 线程中有一个run方法，方法中有一个逻辑为：</span><span style="color:#D19A66;--shiki-dark:#D19A66;">task</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">run</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">，通过底层发现，其实调用的是具体task对象的runTask()方法</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-5-shuffle" tabindex="-1"><a class="header-anchor" href="#_5-5-shuffle"><span>5.5 shuffle</span></a></h3><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  【在</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;shuffleMapTask类&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">中的runTask()方法中】</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">  1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. shuffle</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;写操作&quot;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  --var writer: ShuffleWriter[Any, Any] = null</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">  2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 在写操作之前，也会调用迭代器的方式，所以也可以实现</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;读的操作&quot;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  --writer.write(rdd.iterator(partition, context)......</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  【在</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;resultTask类&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">中的runTask()方法中，那么就得有读数据的操作】</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">  1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. RDD中不保存数据，所以操作的时候数据是一条一条的执行，则会调用迭代器的方法，点击iterator方法</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  -- func(context, rdd.iterator(partition, context))</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">      1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 一层一层的调，在shuffleRDD中的computer中有：</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;读的操作&quot;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       -- SparkEnv.get.shuffleManager.getReader(dep.shuffleHandle, split.index, split.index + 1, context).read()</span></span></code></pre></div><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">&quot;分支1&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">： Shuffle map(Write)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">      1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 点击getWrite</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      -- writer = manager.getWriter[Any, Any](dep.shuffleHandle, partitionId, context)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">            1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. getWriter是一个抽象方法，所在的类为：ShuffleManager，</span><span style="color:#98C379;--shiki-dark:#98C379;">&#39;shuffle管理器&#39;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">，获取其实现类：</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;SortShuffleManager&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">               是一个可排序的shuffleManager管理器。查询这个管理类的getWriter方法，在这个方法中，对handle的类型进行模式匹</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">               配，所以现在handle就很很重要了，从模式匹配项，可以知道有3种不同类型的handle，而且handle来自</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;getWriter方法&quot;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">               -- handle match {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                  case</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> unsafeShuffleHandle: SerializedShuffleHandle</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                  case</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> bypassMergeSortHandle: BypassMergeSortShuffleHandle</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                  case</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> other: BaseShuffleHandle</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">      2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.在 </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;manager.getWriter&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">方法中的handle到底是什么？看源码</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">             1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 是shuffle管理器注册shuffle获取的，点击registerShuffle</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">             --val shuffleHandle: ShuffleHandle = _rdd.context.env.shuffleManager.registerShuffle(</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        shuffleId, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">_rdd</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">partitions</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#C678DD;--shiki-dark:#C678DD;">length</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, this)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">             2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 是一个抽象方法，获取抽象类</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;ShuffleManager&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">的实现类</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;SortShuffleManager&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,查询</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;registerShuffle&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">方法</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    从这里发现，确实有三种handle：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    a、如果忽略索引文件的排序 </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; 创建BypassMergeSortShuffleHandle</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    b、如果可以实现序列化    </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; 创建SerializedShuffleHandle</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                    c、如果不是以上两种      </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; 创建BaseShuffleHandle</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                   --if (SortShuffleWriter.shouldBypassMergeSort(conf, dependency)) {  </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                          new BypassMergeSortShuffleHandle</span><span style="color:#E06C75;--shiki-dark:#E06C75;">[K, V]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            shuffleId, numMaps, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">dependency</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">asInstanceOf</span><span style="color:#E06C75;--shiki-dark:#E06C75;">[ShuffleDependency[K, V, V]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        } </span><span style="color:#C678DD;--shiki-dark:#C678DD;">else</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (</span><span style="color:#D19A66;--shiki-dark:#D19A66;">SortShuffleManager</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">canUseSerializedShuffle</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(dependency)) {  </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                          new SerializedShuffleHandle</span><span style="color:#E06C75;--shiki-dark:#E06C75;">[K, V]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                            shuffleId, numMaps, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">dependency</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">asInstanceOf</span><span style="color:#E06C75;--shiki-dark:#E06C75;">[ShuffleDependency[K, V, V]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        } </span><span style="color:#C678DD;--shiki-dark:#C678DD;">else</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {     </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                          new BaseShuffleHandle(shuffleId, numMaps, dependency)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                      }</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                      1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 点击</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;shouldBypassMergeSort&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,查看什么情况下忽略排序，如果当前rdd的map端有预聚合功能，就</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                         不能忽略排序，如reduceByKey算子</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                        -- if (dep.mapSideCombine) {false}</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        如果map端没有预聚合功能，首先获取忽略合并的阈值，如果没有显示设置，就会默认给200，如果当前RDD的</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        分区器的分区数量小于这个阈值，那么就返回true，则此时创建</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;BypassMergeSortShuffleHandle&quot;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                        --else {</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                        val bypassMergeThreshold: </span><span style="color:#C678DD;--shiki-dark:#C678DD;">Int</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> conf</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">getInt</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;spark.shuffle.sortbypassMergeThreshold&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">200</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                        dep</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">partitioner</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.numPartitions </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&lt;=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> bypassMergeThreshold</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                        -- 所以总结就是当rdd的map端没有预聚合功能，且分区器的分区数量小于阈值，那么就会创建</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">                            &quot;BypassMergeSortShuffleHandle&quot;</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                     2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 点击</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;canUseSerializedShuffle&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,Spark的内存优化后的解决方案,对象序列化后不需要反序列化。</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                          // 通过以下代码可知，创建</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;SerializedShuffleHandle&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">的条件为,满足以下三个条件即可：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                             a、序列化对象需要</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;支持&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">重定义</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                             b、依赖的map端</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;没有&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">预聚合功能</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                             c、分区数量</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;小于&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> &lt;&lt;</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 24</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) - </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 16777215</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                          if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (!</span><span style="color:#D19A66;--shiki-dark:#D19A66;">dependency</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">serializer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.supportsRelocationOfSerializedObjects) { false} </span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                          else</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (</span><span style="color:#D19A66;--shiki-dark:#D19A66;">dependency</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">mapSideCombine</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) {false } </span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                          else</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (numPartitions </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> MAX_SHUFFLE_OUTPUT_PARTITIONS_FOR_SERIALIZED_MODE) { false} </span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">                          else</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {true }</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">                     3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 如果以上两个handle都不满足，则选择最后一个handle：</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;BaseShuffleHandle&quot;</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> --&gt;默认的handle</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                                             </span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">&quot;分支2&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：Shuffle reduce(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">Read</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 总结： shuffle的handle有三种：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">     1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. BypassMergeSortShuffleHandle  </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; BypassMergeSortShuffleWriter</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">        &quot;条件&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        a、当前rdd的map端没有预聚合功能，如groupBy</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        b、分区器的分区数量小于阈值,默认为200        </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">     2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. SerializedShuffleHandle      </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; UnsafeShuffleWriter</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">        &quot;条件&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        a、序列化对象需要</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;支持&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">重定义</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        b、依赖的map端</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;没有&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">预聚合功能</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        c、分区数量</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;小于&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> &lt;&lt;</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 24</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) - </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 16777215</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">     3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. BaseShuffleHandle           </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; SortShuffleWriter</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">        &quot;默认的handle&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">如果前两种都不满足，那么就使用默认的write</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">拿着这三种handle，再来看这个</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;getWrite&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">方法</span></span></code></pre></div><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  -- handle match {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     -- case unsafeShuffleHandle: SerializedShuffleHandle =&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        new UnsafeShuffleWriter....  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     -- case bypassMergeSortHandle: BypassMergeSortShuffleHandle =&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        new BypassMergeSortShuffleWriter....</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     -- case other: BaseShuffleHandle =&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        new SortShuffleWriter....</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;"> &quot;不同的handle对应不同的writer&quot;</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">     1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. BypassMergeSortShuffleHandle  </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; BypassMergeSortShuffleWriter</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        // 点击</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;BypassMergeSortShuffleWriter&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">中的write方法，如下代码，根据分区的数量进行循环，</span><span style="color:#98C379;--shiki-dark:#98C379;">&#39;每一个分区就向磁盘写一个文</span></span>
<span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">        件&#39;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">。 即map端的每一个task会为reduce端的每一个task都创建一个临时磁盘文件,根据key的hashcode%分区数量，决定数据去到</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        哪个分区文件中。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        -- for (int i = 0; i &lt; numPartitions; i++) {</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      partitionWriters</span><span style="color:#E06C75;--shiki-dark:#E06C75;">[i]</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> blockManager</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">getDiskWriter</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(blockId, </span><span style="color:#C678DD;--shiki-dark:#C678DD;">file</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, serInstance, fileBufferSize, writeMetrics);}</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">       </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">     2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. SerializedShuffleHandle       </span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--&gt; UnsafeShuffleWriter </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   </span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">     3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. BaseShuffleHandle,</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;重要&quot;</span><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       --&gt; SortShuffleWriter</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">         // 点击</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;SortShuffleWriter&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">中的write方法，如下代码：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        // </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;写文件过程&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：写磁盘文件时，首先将数据写到内存中，并在内存中的进行排序，如果内存（5M）不够，会溢写磁盘，</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        生成临时文件(一个数据文件，一个索引文件)，最终将所有的临时文件合并(原来的数据文件和索引文件会被删除)成数据</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        文件和索引文件。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">           2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;预聚和的原理&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：在排序时，构造了一种类似于hashtable的结构，所以相同的key就聚合在一起。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">           3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;排序规则&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：首先会按照分区进行排序，然后按照key.</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">           4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;数据进入不同分区的原则&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">：按照分区器的原则，默认是hashpartition，根据key的hash%分区数量。</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">         val partitionLengths </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> sorter</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">writePartitionedFile</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(blockId, tmp)</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">         shuffleBlockResolver</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">writeIndexFileAndCommit</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">...</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>![image-20200621180817513](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200621180817.png)</p><p>![image-20200620004312766](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200620004312.png)</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 面试中常见shuffle的两个问题：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 我们现在spark使用了哪种shuffle，哪一种类型的？</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   a、sortshuffle。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 忽略排序过程的shuffle什么时候会触发？</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   a、map 端没有预聚合功能</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   b、reduce端的分区数量小于一个阈值，默认是200</span></span></code></pre></div><h2 id="六-、-spark内存管理" tabindex="-1"><a class="header-anchor" href="#六-、-spark内存管理"><span>六 、 Spark内存管理</span></a></h2><h3 id="_6-1-堆内内存和堆外内存" tabindex="-1"><a class="header-anchor" href="#_6-1-堆内内存和堆外内存"><span>6.1 堆内内存和堆外内存</span></a></h3><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    --1. &quot;堆内内存&quot;：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        是指jvm所能使用的内存，并不是完全可以控制，如GC垃圾回收器的执行时间是不可控的，当你需要内存进行数据处理时，GC并不能立</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        马释放内存给你使用。jvm虚拟机默认使用的内存大小是可用内存的1/</span><span style="color:#D19A66;--shiki-dark:#D19A66;">64</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">，最大值是1/</span><span style="color:#D19A66;--shiki-dark:#D19A66;">4</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    --2. &quot;堆外内存&quot;：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">         在jvm虚拟机之外的内存，可以存储我们的数据，这个内存是咱们向操作系统申请过来的，完全可控。</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;默认是不启用堆外内存&quot;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    --3. 设置堆外内存的参数：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        a、启动堆外内存参数：</span><span style="color:#D19A66;--shiki-dark:#D19A66;">spark</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">memory</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">offHeap</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">enabled</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        b、设定堆外内存的大小： </span><span style="color:#D19A66;--shiki-dark:#D19A66;">spark</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">memory</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">offHeap</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">size</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    --4. 在spark中，堆内和堆外内存可以进行统一的管理。</span></span></code></pre></div><h3 id="_6-2-内存空间分配" tabindex="-1"><a class="header-anchor" href="#_6-2-内存空间分配"><span>6.2 内存空间分配</span></a></h3><h4 id="_6-2-1-早期内存管理" tabindex="-1"><a class="header-anchor" href="#_6-2-1-早期内存管理"><span>6.2.1 早期内存管理</span></a></h4><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#98C379;--shiki-dark:#98C379;">&quot;早期各个区域的内存分配好了以后，就需要严格遵守这个规则，内存大小不可变。&quot;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--1. 内存空间的分配：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. Storage：缓存RDD数据和广播变量的数据， </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;内存大小占比60%&quot;</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. Execution：用于缓存在shuffle过程中的中间数据， </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;内存大小占比20%&quot;</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. Other：用户自定义的一些数据结构或者是Spark内部的元数据 ： </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;内存大小占比20%&quot;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 2. Storage内存和Execution内存都有预留空间，目的是防止OOM，因为Spark堆内内存大小的记录是不准确的，需要留出保险区域。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 3. 当前不同区域内存大小分配存在的问题：</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      Execution的内存过小，而Storage内存大小过多。</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> 从而就产生了新的内存分配原则</span></span></code></pre></div><ul><li>堆内内存</li></ul><p>![image-20200620012427321](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200620012427.png)</p><ul><li>堆外内存</li></ul><p>![image-20200620015214858](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200620015214.png)</p><h4 id="_6-2-2-统一内存管理" tabindex="-1"><a class="header-anchor" href="#_6-2-2-统一内存管理"><span>6.2.2 统一内存管理</span></a></h4><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 1. 什么是统一内存管理？</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">   Spark1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">6</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> 之后引入的统一内存管理机制，各个区域内存的大小是可变的.</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> --2.与静态内存管理的区别:</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">   统一内存管理</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;存储内存&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">和</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;执行内存共享&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">同一块空间，可以动态占用对方的空闲区域</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 3. 当前spark默认的内存分配是按照统一内存管理的模式。</span></span></code></pre></div><ul><li>堆内内存</li></ul><p>![image-20200620015026859](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200620015026.png)</p><ul><li>堆外内存</li></ul><p>![image-20200620015251558](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200620015251.png)</p><h4 id="_6-2-3-同一管理内存的优点" tabindex="-1"><a class="header-anchor" href="#_6-2-3-同一管理内存的优点"><span>6.2.3 同一管理内存的优点</span></a></h4><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 1. 优点</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)设定基本的存储内存和执行内存区域（</span><span style="color:#D19A66;--shiki-dark:#D19A66;">spark</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">storage</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.storageFraction参数），该设定确定了双方各自拥有的空间的范围；</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)双方的空间都不足时，则存储到硬盘；若己方空间不足而对方空余时，可借用对方的空间;（存储空间不足是指不足以放下一个完整的Block）</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)执行内存的空间被对方占用后，可让对方将占用的部分转存到硬盘，然后”归还”借用的空间；</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)存储内存的空间被对方占用后，无法让对方”归还”，因为需要考虑 Shuffle过程中的很多因素，实现起来较为复杂。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 2. 统一内存管理的动态占用机制图如下：</span></span></code></pre></div><p>![image-20200620015447725](<a href="https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic" target="_blank" rel="noopener noreferrer">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</a> GO/20200620015447.png)</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 注意事项</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 如果是storage借了Execution的内存，那么当Execution需使用时，storage占用Execution的内存就要想办法还给Execution，一般可以进行落盘，但是在内存中的数据有一个存储级别，如果仅仅是Memory_Only的话，那么此时占用内存的数据就会丢失。</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.  如果是Execution借了storage的内存，那么当storage需使用时，Execution并不会把内存还给storage，那么此时storage的数据就会溢写磁盘，如果不能溢写的话，那么就会丢失或淘汰。</span></span></code></pre></div><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 面试题：</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 动态占用机制图是什么情况？</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 为什么cache为丢失数据？</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. 阶段的划分</span></span>
<span class="line"><span style="color:#D19A66;--shiki-dark:#D19A66;">4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">. task的发送</span></span></code></pre></div></div><!--[--><div class="sponsor" data-v-98f29c97><div id="drinks-box" data-v-98f29c97><div id="drinks-box-s" class="drinks-button left-100" data-v-98f29c97><div id="drinks-icons" class="left-100 tr3" data-v-98f29c97><div id="coffee-donate" class="icon-donate" data-v-98f29c97><span class="font-icon icon iconfont icon-hk-flutter" data-v-98f29c97></span> 赞助 </div></div><div id="drinks-button-box" class="tr3 left-100" data-v-98f29c97><div id="drinks-button-bg" class="left-100" data-v-98f29c97></div><div id="github-box" data-v-98f29c97><a href="https://github.com/OrageKK/sponsor-page" target="_blank" data-v-98f29c97>Github</a></div><ul id="donate-buttons" class="list tr3" data-v-98f29c97><li id="paypal_donate" data-v-98f29c97><a href="https://www.paypal.me/oragekk" target="_blank" data-v-98f29c97>Paypal</a></li><!-- <li id="btc_donate" class="donate-button">Bitcoin</li> --><li id="alipay_donate" class="donate-button" data-v-98f29c97>AliPay</li><li id="wechat_donate" class="donate-button2" data-v-98f29c97>WeChat</li></ul></div><div id="drinks-qrcodes" class="left-100 tr3" data-v-98f29c97><div id="drinks-qrcode" data-v-98f29c97></div></div></div></div></div><!--]--><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/MrjackC/mrjackc.github.io/edit/main/src/posts/BigData/08_Spark/8.Spark内核.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><!----></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 845886914@qq.com">MrJason</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/posts/BigData/08_Spark/7.SparkStreaming.html" aria-label="SparkStreaming"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->SparkStreaming</div></a><a class="route-link auto-link next" href="/posts/BigData/08_Spark/4.%20Spark%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%94%B5%E5%95%86%E6%8C%87%E6%A0%87%E7%BB%9F%E8%AE%A1.html" aria-label="Spark实战项目——电商指标统计"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">Spark实战项目——电商指标统计<!----></div></a></nav><div id="vp-comment" class="waline-wrapper" darkmode="false" style="display:block;"><div data-waline provider="Waline"><div class="wl-reaction"><div class="wl-reaction-title">你认为这篇文章怎么样？</div><ul class="wl-reaction-list"><!--[--><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_agree.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_look_down.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_sunglasses.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_pick_nose.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_awkward.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><li class="wl-reaction-item"><div class="wl-reaction-img"><img src="//unpkg.com/@waline/emojis/tieba/tieba_sleep.png"><div class="wl-reaction-votes">0</div></div><div class="wl-reaction-text"></div></li><!--]--></ul></div><div class="wl-comment"><!--v-if--><div class="wl-panel"><div class="wl-header item3"><!--[--><div class="wl-header-item"><label for="wl-nick">昵称</label><input id="wl-nick" class="wl-input wl-nick" name="nick" type="text" value></div><div class="wl-header-item"><label for="wl-mail">邮箱</label><input id="wl-mail" class="wl-input wl-mail" name="mail" type="email" value></div><div class="wl-header-item"><label for="wl-link">网址(可选)</label><input id="wl-link" class="wl-input wl-link" name="link" type="text" value></div><!--]--></div><textarea id="wl-edit" class="wl-editor" placeholder="请留言。(填写邮箱可在被回复时收到邮件提醒)"></textarea><div class="wl-preview" style="display:none;"><hr><h4>预览:</h4><div class="wl-content"></div></div><div class="wl-footer"><div class="wl-actions"><a href="https://guides.github.com/features/mastering-markdown/" title="Markdown Guide" aria-label="Markdown is supported" class="wl-action" target="_blank" rel="noopener noreferrer"><svg width="16" height="16" ariaHidden="true"><path d="M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z" fill="currentColor"></path></svg></a><button type="button" class="wl-action" title="表情" style="display:none;"><svg viewBox="0 0 1024 1024" width="24" height="24"><path d="M563.2 463.3 677 540c1.7 1.2 3.7 1.8 5.8 1.8.7 0 1.4-.1 2-.2 2.7-.5 5.1-2.1 6.6-4.4l25.3-37.8c1.5-2.3 2.1-5.1 1.6-7.8s-2.1-5.1-4.4-6.6l-73.6-49.1 73.6-49.1c2.3-1.5 3.9-3.9 4.4-6.6.5-2.7 0-5.5-1.6-7.8l-25.3-37.8a10.1 10.1 0 0 0-6.6-4.4c-.7-.1-1.3-.2-2-.2-2.1 0-4.1.6-5.8 1.8l-113.8 76.6c-9.2 6.2-14.7 16.4-14.7 27.5.1 11 5.5 21.3 14.7 27.4zM387 348.8h-45.5c-5.7 0-10.4 4.7-10.4 10.4v153.3c0 5.7 4.7 10.4 10.4 10.4H387c5.7 0 10.4-4.7 10.4-10.4V359.2c0-5.7-4.7-10.4-10.4-10.4zm333.8 241.3-41-20a10.3 10.3 0 0 0-8.1-.5c-2.6.9-4.8 2.9-5.9 5.4-30.1 64.9-93.1 109.1-164.4 115.2-5.7.5-9.9 5.5-9.5 11.2l3.9 45.5c.5 5.3 5 9.5 10.3 9.5h.9c94.8-8 178.5-66.5 218.6-152.7 2.4-5 .3-11.2-4.8-13.6zm186-186.1c-11.9-42-30.5-81.4-55.2-117.1-24.1-34.9-53.5-65.6-87.5-91.2-33.9-25.6-71.5-45.5-111.6-59.2-41.2-14-84.1-21.1-127.8-21.1h-1.2c-75.4 0-148.8 21.4-212.5 61.7-63.7 40.3-114.3 97.6-146.5 165.8-32.2 68.1-44.3 143.6-35.1 218.4 9.3 74.8 39.4 145 87.3 203.3.1.2.3.3.4.5l36.2 38.4c1.1 1.2 2.5 2.1 3.9 2.6 73.3 66.7 168.2 103.5 267.5 103.5 73.3 0 145.2-20.3 207.7-58.7 37.3-22.9 70.3-51.5 98.1-85 27.1-32.7 48.7-69.5 64.2-109.1 15.5-39.7 24.4-81.3 26.6-123.8 2.4-43.6-2.5-87-14.5-129zm-60.5 181.1c-8.3 37-22.8 72-43 104-19.7 31.1-44.3 58.6-73.1 81.7-28.8 23.1-61 41-95.7 53.4-35.6 12.7-72.9 19.1-110.9 19.1-82.6 0-161.7-30.6-222.8-86.2l-34.1-35.8c-23.9-29.3-42.4-62.2-55.1-97.7-12.4-34.7-18.8-71-19.2-107.9-.4-36.9 5.4-73.3 17.1-108.2 12-35.8 30-69.2 53.4-99.1 31.7-40.4 71.1-72 117.2-94.1 44.5-21.3 94-32.6 143.4-32.6 49.3 0 97 10.8 141.8 32 34.3 16.3 65.3 38.1 92 64.8 26.1 26 47.5 56 63.6 89.2 16.2 33.2 26.6 68.5 31 105.1 4.6 37.5 2.7 75.3-5.6 112.3z" fill="currentColor"></path></svg></button><button type="button" class="wl-action" title="表情包"><svg width="24" height="24" fill="currentcolor" viewBox="0 0 24 24"><path style="transform: translateY(0.5px)" d="M18.968 10.5H15.968V11.484H17.984V12.984H15.968V15H14.468V9H18.968V10.5V10.5ZM8.984 9C9.26533 9 9.49967 9.09367 9.687 9.281C9.87433 9.46833 9.968 9.70267 9.968 9.984V10.5H6.499V13.5H8.468V12H9.968V14.016C9.968 14.2973 9.87433 14.5317 9.687 14.719C9.49967 14.9063 9.26533 15 8.984 15H5.984C5.70267 15 5.46833 14.9063 5.281 14.719C5.09367 14.5317 5 14.2973 5 14.016V9.985C5 9.70367 5.09367 9.46933 5.281 9.282C5.46833 9.09467 5.70267 9.001 5.984 9.001H8.984V9ZM11.468 9H12.968V15H11.468V9V9Z"></path><path d="M18.5 3H5.75C3.6875 3 2 4.6875 2 6.75V18C2 20.0625 3.6875 21.75 5.75 21.75H18.5C20.5625 21.75 22.25 20.0625 22.25 18V6.75C22.25 4.6875 20.5625 3 18.5 3ZM20.75 18C20.75 19.2375 19.7375 20.25 18.5 20.25H5.75C4.5125 20.25 3.5 19.2375 3.5 18V6.75C3.5 5.5125 4.5125 4.5 5.75 4.5H18.5C19.7375 4.5 20.75 5.5125 20.75 6.75V18Z"></path></svg></button><input id="wl-image-upload" class="upload" aria-hidden="true" type="file" accept=".png,.jpg,.jpeg,.webp,.bmp,.gif"><label for="wl-image-upload" class="wl-action" title="上传图片" aria-label="上传图片"><svg viewBox="0 0 1024 1024" width="24" height="24"><path d="M784 112H240c-88 0-160 72-160 160v480c0 88 72 160 160 160h544c88 0 160-72 160-160V272c0-88-72-160-160-160zm96 640c0 52.8-43.2 96-96 96H240c-52.8 0-96-43.2-96-96V272c0-52.8 43.2-96 96-96h544c52.8 0 96 43.2 96 96v480z" fill="currentColor"></path><path d="M352 480c52.8 0 96-43.2 96-96s-43.2-96-96-96-96 43.2-96 96 43.2 96 96 96zm0-128c17.6 0 32 14.4 32 32s-14.4 32-32 32-32-14.4-32-32 14.4-32 32-32zm462.4 379.2-3.2-3.2-177.6-177.6c-25.6-25.6-65.6-25.6-91.2 0l-80 80-36.8-36.8c-25.6-25.6-65.6-25.6-91.2 0L200 728c-4.8 6.4-8 14.4-8 24 0 17.6 14.4 32 32 32 9.6 0 16-3.2 22.4-9.6L380.8 640l134.4 134.4c6.4 6.4 14.4 9.6 24 9.6 17.6 0 32-14.4 32-32 0-9.6-4.8-17.6-9.6-24l-52.8-52.8 80-80L769.6 776c6.4 4.8 12.8 8 20.8 8 17.6 0 32-14.4 32-32 0-8-3.2-16-8-20.8z" fill="currentColor"></path></svg></label><button type="button" class="wl-action" title="预览"><svg viewBox="0 0 1024 1024" width="24" height="24"><path d="M710.816 654.301c70.323-96.639 61.084-230.578-23.705-314.843-46.098-46.098-107.183-71.109-172.28-71.109-65.008 0-126.092 25.444-172.28 71.109-45.227 46.098-70.756 107.183-70.756 172.106 0 64.923 25.444 126.007 71.194 172.106 46.099 46.098 107.184 71.109 172.28 71.109 51.414 0 100.648-16.212 142.824-47.404l126.53 126.006c7.058 7.06 16.297 10.979 26.406 10.979 10.105 0 19.343-3.919 26.402-10.979 14.467-14.467 14.467-38.172 0-52.723L710.816 654.301zm-315.107-23.265c-65.88-65.88-65.88-172.54 0-238.42 32.069-32.07 74.245-49.149 119.471-49.149 45.227 0 87.407 17.603 119.472 49.149 65.88 65.879 65.88 172.539 0 238.42-63.612 63.178-175.242 63.178-238.943 0zm0 0" fill="currentColor"></path><path d="M703.319 121.603H321.03c-109.8 0-199.469 89.146-199.469 199.38v382.034c0 109.796 89.236 199.38 199.469 199.38h207.397c20.653 0 37.384-16.645 37.384-37.299 0-20.649-16.731-37.296-37.384-37.296H321.03c-68.582 0-124.352-55.77-124.352-124.267V321.421c0-68.496 55.77-124.267 124.352-124.267h382.289c68.582 0 124.352 55.771 124.352 124.267V524.72c0 20.654 16.736 37.299 37.385 37.299 20.654 0 37.384-16.645 37.384-37.299V320.549c-.085-109.8-89.321-198.946-199.121-198.946zm0 0" fill="currentColor"></path></svg></button></div><div class="wl-info"><div class="wl-captcha-container"></div><div class="wl-text-number">0 <span>  /  <span class="">300</span></span>  字</div><button type="button" class="wl-btn">登录</button><button type="submit" class="primary wl-btn" title="Cmd|Ctrl + Enter"><!--[-->提交<!--]--></button></div><div class="wl-gif-popup"><input type="text" placeholder="搜索表情包"><!--v-if--><div class="wl-loading"><svg width="30" height="30" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid"><circle cx="50" cy="50" fill="none" stroke="currentColor" strokeWidth="4" r="40" stroke-dasharray="85 30"><animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" values="0 50 50;360 50 50" keyTimes="0;1"></animateTransform></circle></svg></div></div><div class="wl-emoji-popup"><!--[--><!--]--><!--v-if--></div></div></div><!--v-if--></div><div class="wl-meta-head"><div class="wl-count"><!--v-if--> 评论</div><ul class="wl-sort"><!--[--><li class="active">按正序</li><li class="">按倒序</li><li class="">按热度</li><!--]--></ul></div><div class="wl-cards"><!--[--><!--]--></div><div class="wl-loading"><svg width="30" height="30" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid"><circle cx="50" cy="50" fill="none" stroke="currentColor" strokeWidth="4" r="40" stroke-dasharray="85 30"><animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" values="0 50 50;360 50 50" keyTimes="0;1"></animateTransform></circle></svg></div><div class="wl-power"> Powered by <a href="https://github.com/walinejs/waline" target="_blank" rel="noopener noreferrer"> Waline </a> v3.3.2</div></div></div><!----><!--]--></main><!--]--><div style="--0dfcb062:;"><footer class="footer-wrapper" style="display:none;"><div class="busuanzi"><span id="busuanzi_container_site_pv" style="display:none;"> 本站总访问量 <span id="busuanzi_value_site_pv"></span>次 <span class="post-meta-divider">|</span></span><span id="busuanzi_container_site_uv" style="display:none;"> 您是本站第 <span id="busuanzi_value_site_uv"></span>位访问者 </span></div><div class="footer-content"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2020-2024 MrJason</div></div><span id="runtime_span"></span><div class="footer-link"><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_1.gif" alt="" style="width:auto;height:32px;" title="穿梭虫洞-随机访问十年之约友链博客"></a><a href="https://www.travellings.cn/go.html" target="_blank"><img src="https://www.travellings.cn/assets/logo.gif" alt="" style="width:auto;height:32px;" title="开往-友链接力"></a></div></footer></div></div><!--]--><!--[--><!----><!----><div></div><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-W9QyTiMU.js" defer></script>
  </body>
</html>
